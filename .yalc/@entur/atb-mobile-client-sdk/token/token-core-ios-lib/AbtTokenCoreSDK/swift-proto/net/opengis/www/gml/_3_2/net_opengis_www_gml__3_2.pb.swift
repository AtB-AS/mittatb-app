// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: net/opengis/www/gml/_3_2/net_opengis_www_gml__3_2.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// /home/circleci/project/protobuf-reduced-traveller/target/proto_deps/net/opengis/www/gml/_3_2/net_opengis_www_gml__3_2.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Direct position instances hold the coordinates for a position within some coordinate reference system (CRS). Since direct positions, as data types, will often be included in larger objects (such as geometry elements) that have references to CRS, the srsName attribute will in general be missing, if this particular direct position is included in a larger element with such a reference to a CRS. In this case, the CRS is implicitly assumed to take on the value of the containing object's CRS. if no srsName attribute is given, the CRS shall be specified as part of the larger context this geometry element is part of, typically a geometric object like a point, curve, etc.  [gml/geometryBasic0d1d-extract-v3_2_1.xsd at 73:41]
struct Net_Opengis_Www_Gml_32_DirectPositionType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [gml/geometryBasic0d1d-extract-v3_2_1.xsd at 36:44]
  var srsName: String = String()

  /// [gml/geometryBasic0d1d-extract-v3_2_1.xsd at 37:58]
  var srsDimension: UInt32 = 0

  /// Direct position instances hold the coordinates for a position within some coordinate reference system (CRS). Since direct positions, as data types, will often be included in larger objects (such as geometry elements) that have references to CRS, the srsName attribute will in general be missing, if this particular direct position is included in a larger element with such a reference to a CRS. In this case, the CRS is implicitly assumed to take on the value of the containing object's CRS. if no srsName attribute is given, the CRS shall be specified as part of the larger context this geometry element is part of, typically a geometric object like a point, curve, etc.  [gml/geometryBasic0d1d-extract-v3_2_1.xsd at 73:41]
  var value: [Double] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Net_Opengis_Www_Gml_32_DirectPositionType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "net.opengis.www.gml._3_2"

extension Net_Opengis_Www_Gml_32_DirectPositionType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DirectPositionType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "srs_name"),
    2: .standard(proto: "srs_dimension"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.srsName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.srsDimension) }()
      case 3: try { try decoder.decodeRepeatedDoubleField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.srsName.isEmpty {
      try visitor.visitSingularStringField(value: self.srsName, fieldNumber: 1)
    }
    if self.srsDimension != 0 {
      try visitor.visitSingularUInt32Field(value: self.srsDimension, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitPackedDoubleField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_Opengis_Www_Gml_32_DirectPositionType, rhs: Net_Opengis_Www_Gml_32_DirectPositionType) -> Bool {
    if lhs.srsName != rhs.srsName {return false}
    if lhs.srsDimension != rhs.srsDimension {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
