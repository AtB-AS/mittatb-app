// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: no/entur/abt/common/Common_Messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// /home/circleci/project/protobuf-reduced-traveller/target/proto_deps/no/entur/abt/common/Common_Messages.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///  Command id. Combination of id+sub_id must be unique. Used for idempotency
struct No_Entur_Abt_Common_V1_CommandId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Main Id is required, pattern is either a stable UUID (recommended) or on the format MySystem:MyUniqueIdentifier.
  var id: String = String()

  /// Optional subId. Used to differentiate a group of connected commands
  var subID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information required to initialize a new Mobile token
struct No_Entur_Abt_Common_V1_MobileTokenInitializationData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The uuid of the token
  var tokenID: String = String()

  /// Nonce created by server. Must be included when traveller application completes registration process, either as a part of the attestation (if required) or explicit in the request (if not)
  var nonce: Data = Data()

  /// Time-to-live for the nonce. Registration process must be completed within this time
  var nonceValidityEnd: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _nonceValidityEnd ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_nonceValidityEnd = newValue}
  }
  /// Returns true if `nonceValidityEnd` has been explicitly set.
  var hasNonceValidityEnd: Bool {return self._nonceValidityEnd != nil}
  /// Clears the value of `nonceValidityEnd`. Subsequent reads from it will return its default value.
  mutating func clearNonceValidityEnd() {self._nonceValidityEnd = nil}

  /// Only relevant for IOS Device Check attestation. The attestation encryption public key (RSA). Used by ios devices to encrypt the AES key for the encrypted attestation data. So that the data can be verified on the server.
  var attestationEncryptionPublicKey: Data = Data()

  /// The Customer account that the new token belongs to
  var customerAccountID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nonceValidityEnd: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Reattestation requirements for a Mobile token. Returned as error details to the client when the server has decided that the device must perform a new device attestation before further requests are allowed.
struct No_Entur_Abt_Common_V1_MobileTokenReattestationData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The uuid of the token
  var tokenID: String = String()

  /// A short lived secret that the device must include in the attestation data
  var nonce: Data = Data()

  /// Only relevant for IOS Device Check attestation. The attestation encryption public key (RSA). Used by ios devices to encrypt the AES key for the encrypted attestation data. So that the data can be verified on the server.
  var attestationEncryptionPublicKey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Metadata for a token travel document
struct No_Entur_Abt_Common_V1_TokenTravelDocumentMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of token
  var name: Uk_Org_Netex_Www_Netex_MultilingualString {
    get {return _name ?? Uk_Org_Netex_Www_Netex_MultilingualString()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// Description for token
  var description_p: Uk_Org_Netex_Www_Netex_MultilingualString {
    get {return _description_p ?? Uk_Org_Netex_Www_Netex_MultilingualString()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  /// Metadata for token
  var keyList: Uk_Org_Netex_Www_Netex_KeyListStructure {
    get {return _keyList ?? Uk_Org_Netex_Www_Netex_KeyListStructure()}
    set {_keyList = newValue}
  }
  /// Returns true if `keyList` has been explicitly set.
  var hasKeyList: Bool {return self._keyList != nil}
  /// Clears the value of `keyList`. Subsequent reads from it will return its default value.
  mutating func clearKeyList() {self._keyList = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: Uk_Org_Netex_Www_Netex_MultilingualString? = nil
  fileprivate var _description_p: Uk_Org_Netex_Www_Netex_MultilingualString? = nil
  fileprivate var _keyList: Uk_Org_Netex_Www_Netex_KeyListStructure? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension No_Entur_Abt_Common_V1_CommandId: @unchecked Sendable {}
extension No_Entur_Abt_Common_V1_MobileTokenInitializationData: @unchecked Sendable {}
extension No_Entur_Abt_Common_V1_MobileTokenReattestationData: @unchecked Sendable {}
extension No_Entur_Abt_Common_V1_TokenTravelDocumentMetadata: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "no.entur.abt.common.v1"

extension No_Entur_Abt_Common_V1_CommandId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "sub_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.subID.isEmpty {
      try visitor.visitSingularStringField(value: self.subID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Common_V1_CommandId, rhs: No_Entur_Abt_Common_V1_CommandId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.subID != rhs.subID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Common_V1_MobileTokenInitializationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MobileTokenInitializationData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "nonce_validity_end"),
    4: .standard(proto: "attestation_encryption_public_key"),
    5: .standard(proto: "customer_account_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._nonceValidityEnd) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.attestationEncryptionPublicKey) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.customerAccountID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 1)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 2)
    }
    try { if let v = self._nonceValidityEnd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.attestationEncryptionPublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.attestationEncryptionPublicKey, fieldNumber: 4)
    }
    if !self.customerAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.customerAccountID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Common_V1_MobileTokenInitializationData, rhs: No_Entur_Abt_Common_V1_MobileTokenInitializationData) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs._nonceValidityEnd != rhs._nonceValidityEnd {return false}
    if lhs.attestationEncryptionPublicKey != rhs.attestationEncryptionPublicKey {return false}
    if lhs.customerAccountID != rhs.customerAccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Common_V1_MobileTokenReattestationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MobileTokenReattestationData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "attestation_encryption_public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.attestationEncryptionPublicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 1)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 2)
    }
    if !self.attestationEncryptionPublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.attestationEncryptionPublicKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Common_V1_MobileTokenReattestationData, rhs: No_Entur_Abt_Common_V1_MobileTokenReattestationData) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.attestationEncryptionPublicKey != rhs.attestationEncryptionPublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Common_V1_TokenTravelDocumentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenTravelDocumentMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "key_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._keyList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._keyList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Common_V1_TokenTravelDocumentMetadata, rhs: No_Entur_Abt_Common_V1_TokenTravelDocumentMetadata) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._keyList != rhs._keyList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
