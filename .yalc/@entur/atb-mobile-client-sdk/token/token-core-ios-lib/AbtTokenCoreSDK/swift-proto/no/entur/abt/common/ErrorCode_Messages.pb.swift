// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: no/entur/abt/common/ErrorCode_Messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// /home/circleci/project/protobuf-reduced-traveller/target/proto_deps/no/entur/abt/common/ErrorCode_Messages.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Reason codes used as string values in 'reason' field in ErrorInfo details provided with API errors. Metadata value with key="errorCode" provide further details according to corresponding XXXErrorCode enums.
enum No_Entur_Abt_Common_V1_ErrorInfoReason: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0

  /// Request was rejected because token is not valid
  case tokenInvalid // = 1

  /// Request was rejected because device attestation was not successful. Further details in metadata with key="errorCode"
  case deviceAttestationFailed // = 3

  /// Request was rejected because key attestation was not successful. Further details in metadata with key="errorCode"
  case keyAttestationFailed // = 4

  /// Authentication was missing from a request where it is required. No details.
  case authenticationRequired // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .tokenInvalid
    case 3: self = .deviceAttestationFailed
    case 4: self = .keyAttestationFailed
    case 5: self = .authenticationRequired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .tokenInvalid: return 1
    case .deviceAttestationFailed: return 3
    case .keyAttestationFailed: return 4
    case .authenticationRequired: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension No_Entur_Abt_Common_V1_ErrorInfoReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [No_Entur_Abt_Common_V1_ErrorInfoReason] = [
    .unspecified,
    .tokenInvalid,
    .deviceAttestationFailed,
    .keyAttestationFailed,
    .authenticationRequired,
  ]
}

#endif  // swift(>=4.2)

/// Error codes used to details error messages when ErrorInfoReason=ERROR_INFO_REASON_TOKEN_INVALID
enum No_Entur_Abt_Common_V1_TokenInvalidErrorCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0

  /// Token has been expired for ordinary use, but can still be used to renew the token. Renew ASAP
  case mustBeRenewed // = 1

  /// Token has been expired for all use and must be replaced from Account Provider.
  case mustBeReplaced // = 2

  /// Token does not exist.
  case notFound // = 3

  /// Token is valid, but encoding is not. See message for reason, ie invalid signature, clock skew, invalid certificate, type mismatch etc
  case encodingInvalid // = 4

  /// Token is valid, but does have sufficient privileges for current operation
  case permissionDenied // = 5

  /// Token validity has not yet started.
  case validityNotStarted // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .mustBeRenewed
    case 2: self = .mustBeReplaced
    case 3: self = .notFound
    case 4: self = .encodingInvalid
    case 5: self = .permissionDenied
    case 6: self = .validityNotStarted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .mustBeRenewed: return 1
    case .mustBeReplaced: return 2
    case .notFound: return 3
    case .encodingInvalid: return 4
    case .permissionDenied: return 5
    case .validityNotStarted: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension No_Entur_Abt_Common_V1_TokenInvalidErrorCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [No_Entur_Abt_Common_V1_TokenInvalidErrorCode] = [
    .unspecified,
    .mustBeRenewed,
    .mustBeReplaced,
    .notFound,
    .encodingInvalid,
    .permissionDenied,
    .validityNotStarted,
  ]
}

#endif  // swift(>=4.2)

/// Error codes used to details error messages when ErrorInfoReason=ERROR_INFO_REASON_DEVICE_ATTESTATION_FAILED
enum No_Entur_Abt_Common_V1_DeviceAttestationErrorCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0

  /// Device attestation has invalid format. Indicates an error in client code.
  case formatInvalid // = 2

  /// Nonce used in device attestation has expired.  Obtain a new nonce from server in the same manner the previous nonce was obtained.
  case nonceExpired // = 3

  /// Nonce in attestation does not match expected nonce.
  case nonceMismatch // = 4

  /// Attested data does not match expected. Indicates an error in client code.
  case deviceAttestationErrorDataMismatch // = 5

  /// Attestation type is not allowed for token.
  case deviceAttestationErrorTypeInvalid // = 11

  /// Signature for device attestation is missing or invalid. Indicates an error in client code.
  case signatureInvalid // = 6

  /// Device attestation is for unknown/invalid mobil application. Mobile application must be registered in abt-core
  case mobileApplicationInvalid // = 7

  /// APPLICATION_ID in deviceInfo does not match attested application id
  case mobileApplicationMismatch // = 8

  /// Device attestation has missing or too old/new timestamp. Indicates that attestation was not obtained correctly for this request.
  case timestampInvalid // = 9

  /// The device is not supported for enrollment. This type of device is missing necessary functionality to act as a token.
  case deviceUnsupported // = 10

  /// Basic integrity flag in safety net attestation was not set. Indicates that device has been tampered with.
  case androidSafetyNetBasicIntegrityRejected // = 20

  /// Cts profile match flag in safety net attestation was not set. Indicates that device has been tampered with.
  case androidSafetyNetCtsProfileMatchRejected // = 21

  /// The apple device check API rejected the device token. Probably invalid
  case iosDeviceCheckDeviceTokenRejected // = 22

  /// The apple device check API rejected the jwt token. It is invalid or expired.
  case iosDeviceCheckJwtTokenRejected // = 23

  /// Parsing of the apple device attest input data failed.
  case iosDeviceAttestInvalidInputData // = 24

  /// Validation of the apple app attest failed. Probably invalid.
  case iosDeviceAttestValidationFailed // = 25

  /// Specified attestation environment not allowed. Returned when client specifies iOS AppAttest development/sandbox environment in env where not allowed
  case environmentNotAllowed // = 26
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 2: self = .formatInvalid
    case 3: self = .nonceExpired
    case 4: self = .nonceMismatch
    case 5: self = .deviceAttestationErrorDataMismatch
    case 6: self = .signatureInvalid
    case 7: self = .mobileApplicationInvalid
    case 8: self = .mobileApplicationMismatch
    case 9: self = .timestampInvalid
    case 10: self = .deviceUnsupported
    case 11: self = .deviceAttestationErrorTypeInvalid
    case 20: self = .androidSafetyNetBasicIntegrityRejected
    case 21: self = .androidSafetyNetCtsProfileMatchRejected
    case 22: self = .iosDeviceCheckDeviceTokenRejected
    case 23: self = .iosDeviceCheckJwtTokenRejected
    case 24: self = .iosDeviceAttestInvalidInputData
    case 25: self = .iosDeviceAttestValidationFailed
    case 26: self = .environmentNotAllowed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .formatInvalid: return 2
    case .nonceExpired: return 3
    case .nonceMismatch: return 4
    case .deviceAttestationErrorDataMismatch: return 5
    case .signatureInvalid: return 6
    case .mobileApplicationInvalid: return 7
    case .mobileApplicationMismatch: return 8
    case .timestampInvalid: return 9
    case .deviceUnsupported: return 10
    case .deviceAttestationErrorTypeInvalid: return 11
    case .androidSafetyNetBasicIntegrityRejected: return 20
    case .androidSafetyNetCtsProfileMatchRejected: return 21
    case .iosDeviceCheckDeviceTokenRejected: return 22
    case .iosDeviceCheckJwtTokenRejected: return 23
    case .iosDeviceAttestInvalidInputData: return 24
    case .iosDeviceAttestValidationFailed: return 25
    case .environmentNotAllowed: return 26
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension No_Entur_Abt_Common_V1_DeviceAttestationErrorCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [No_Entur_Abt_Common_V1_DeviceAttestationErrorCode] = [
    .unspecified,
    .formatInvalid,
    .nonceExpired,
    .nonceMismatch,
    .deviceAttestationErrorDataMismatch,
    .deviceAttestationErrorTypeInvalid,
    .signatureInvalid,
    .mobileApplicationInvalid,
    .mobileApplicationMismatch,
    .timestampInvalid,
    .deviceUnsupported,
    .androidSafetyNetBasicIntegrityRejected,
    .androidSafetyNetCtsProfileMatchRejected,
    .iosDeviceCheckDeviceTokenRejected,
    .iosDeviceCheckJwtTokenRejected,
    .iosDeviceAttestInvalidInputData,
    .iosDeviceAttestValidationFailed,
    .environmentNotAllowed,
  ]
}

#endif  // swift(>=4.2)

/// Error codes used to details error messages when ErrorInfoReason=ERROR_INFO_REASON_KEY_ATTESTATION_FAILED
enum No_Entur_Abt_Common_V1_KeyAttestationErrorCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0

  /// Key attestation is missing. Indicates an error in client code.
  case missing // = 1

  /// Key attestation has invalid format. Indicates an error in client code.
  case formatInvalid // = 2

  /// Mismatch between the public key to be attested and the actual key in the key attestation. Indicates that this attestation was not obtained for the correct key.
  case publicKeyMismatch // = 3

  /// Mismatch between the challenge (nonce) to be attested and the actual challenge in the key attestation. Indicates that this attestation was not obtained for the correct key or that the key was generated without the correct challenge.
  case challengeMismatch // = 4

  /// Certificate chain is invalid because one of the certificates has been revoked. Chain of certificate for this device is no longer trusted.
  case certificateRevoked // = 5

  /// Security level for key from key store is too low. The key is not stored in hw keystore.
  case securityLevelInsufficient // = 6

  /// Root certificate is not accepted.  Chain of certificate for this device is not trusted.
  case rootCertificateInvalid // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .missing
    case 2: self = .formatInvalid
    case 3: self = .publicKeyMismatch
    case 4: self = .challengeMismatch
    case 5: self = .certificateRevoked
    case 6: self = .securityLevelInsufficient
    case 7: self = .rootCertificateInvalid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .missing: return 1
    case .formatInvalid: return 2
    case .publicKeyMismatch: return 3
    case .challengeMismatch: return 4
    case .certificateRevoked: return 5
    case .securityLevelInsufficient: return 6
    case .rootCertificateInvalid: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension No_Entur_Abt_Common_V1_KeyAttestationErrorCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [No_Entur_Abt_Common_V1_KeyAttestationErrorCode] = [
    .unspecified,
    .missing,
    .formatInvalid,
    .publicKeyMismatch,
    .challengeMismatch,
    .certificateRevoked,
    .securityLevelInsufficient,
    .rootCertificateInvalid,
  ]
}

#endif  // swift(>=4.2)

/// Violation type codes used to details error messages for PreconditionFailures.
enum No_Entur_Abt_Common_V1_PreconditionFailureType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0

  /// Reattestation required
  case reattestationRequired // = 1

  /// Entity is not in the correct state to perform state change implied by command
  case lifecycleStateChangeIllegal // = 2

  /// A referenced entity was not found/not of correct type/not in correct state/did not have correct attributes
  case referenceInvalid // = 3

  /// Minimum or current security level on CustomerAccount does not allow operation
  case securityLevelInsufficient // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .reattestationRequired
    case 2: self = .lifecycleStateChangeIllegal
    case 3: self = .referenceInvalid
    case 4: self = .securityLevelInsufficient
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .reattestationRequired: return 1
    case .lifecycleStateChangeIllegal: return 2
    case .referenceInvalid: return 3
    case .securityLevelInsufficient: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension No_Entur_Abt_Common_V1_PreconditionFailureType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [No_Entur_Abt_Common_V1_PreconditionFailureType] = [
    .unspecified,
    .reattestationRequired,
    .lifecycleStateChangeIllegal,
    .referenceInvalid,
    .securityLevelInsufficient,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension No_Entur_Abt_Common_V1_ErrorInfoReason: @unchecked Sendable {}
extension No_Entur_Abt_Common_V1_TokenInvalidErrorCode: @unchecked Sendable {}
extension No_Entur_Abt_Common_V1_DeviceAttestationErrorCode: @unchecked Sendable {}
extension No_Entur_Abt_Common_V1_KeyAttestationErrorCode: @unchecked Sendable {}
extension No_Entur_Abt_Common_V1_PreconditionFailureType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension No_Entur_Abt_Common_V1_ErrorInfoReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_INFO_REASON_UNSPECIFIED"),
    1: .same(proto: "ERROR_INFO_REASON_TOKEN_INVALID"),
    3: .same(proto: "ERROR_INFO_REASON_DEVICE_ATTESTATION_FAILED"),
    4: .same(proto: "ERROR_INFO_REASON_KEY_ATTESTATION_FAILED"),
    5: .same(proto: "ERROR_INFO_REASON_AUTHENTICATION_REQUIRED"),
  ]
}

extension No_Entur_Abt_Common_V1_TokenInvalidErrorCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TOKEN_INVALID_ERROR_CODE_UNSPECIFIED"),
    1: .same(proto: "TOKEN_INVALID_ERROR_CODE_MUST_BE_RENEWED"),
    2: .same(proto: "TOKEN_INVALID_ERROR_CODE_MUST_BE_REPLACED"),
    3: .same(proto: "TOKEN_INVALID_ERROR_CODE_NOT_FOUND"),
    4: .same(proto: "TOKEN_INVALID_ERROR_CODE_ENCODING_INVALID"),
    5: .same(proto: "TOKEN_INVALID_ERROR_CODE_PERMISSION_DENIED"),
    6: .same(proto: "TOKEN_INVALID_ERROR_CODE_VALIDITY_NOT_STARTED"),
  ]
}

extension No_Entur_Abt_Common_V1_DeviceAttestationErrorCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_UNSPECIFIED"),
    2: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_FORMAT_INVALID"),
    3: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_NONCE_EXPIRED"),
    4: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_NONCE_MISMATCH"),
    5: .same(proto: "DEVICE_ATTESTATION_ERROR_DATA_MISMATCH"),
    6: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_SIGNATURE_INVALID"),
    7: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_MOBILE_APPLICATION_INVALID"),
    8: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_MOBILE_APPLICATION_MISMATCH"),
    9: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_TIMESTAMP_INVALID"),
    10: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_DEVICE_UNSUPPORTED"),
    11: .same(proto: "DEVICE_ATTESTATION_ERROR_TYPE_INVALID"),
    20: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_ANDROID_SAFETY_NET_BASIC_INTEGRITY_REJECTED"),
    21: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_ANDROID_SAFETY_NET_CTS_PROFILE_MATCH_REJECTED"),
    22: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_IOS_DEVICE_CHECK_DEVICE_TOKEN_REJECTED"),
    23: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_IOS_DEVICE_CHECK_JWT_TOKEN_REJECTED"),
    24: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_IOS_DEVICE_ATTEST_INVALID_INPUT_DATA"),
    25: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_IOS_DEVICE_ATTEST_VALIDATION_FAILED"),
    26: .same(proto: "DEVICE_ATTESTATION_ERROR_CODE_ENVIRONMENT_NOT_ALLOWED"),
  ]
}

extension No_Entur_Abt_Common_V1_KeyAttestationErrorCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY_ATTESTATION_ERROR_CODE_UNSPECIFIED"),
    1: .same(proto: "KEY_ATTESTATION_ERROR_CODE_MISSING"),
    2: .same(proto: "KEY_ATTESTATION_ERROR_CODE_FORMAT_INVALID"),
    3: .same(proto: "KEY_ATTESTATION_ERROR_CODE_PUBLIC_KEY_MISMATCH"),
    4: .same(proto: "KEY_ATTESTATION_ERROR_CODE_CHALLENGE_MISMATCH"),
    5: .same(proto: "KEY_ATTESTATION_ERROR_CODE_CERTIFICATE_REVOKED"),
    6: .same(proto: "KEY_ATTESTATION_ERROR_CODE_SECURITY_LEVEL_INSUFFICIENT"),
    7: .same(proto: "KEY_ATTESTATION_ERROR_CODE_ROOT_CERTIFICATE_INVALID"),
  ]
}

extension No_Entur_Abt_Common_V1_PreconditionFailureType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRECONDITION_FAILURE_TYPE_UNSPECIFIED"),
    1: .same(proto: "PRECONDITION_FAILURE_TYPE_REATTESTATION_REQUIRED"),
    2: .same(proto: "PRECONDITION_FAILURE_TYPE_LIFECYCLE_STATE_CHANGE_ILLEGAL"),
    3: .same(proto: "PRECONDITION_FAILURE_TYPE_REFERENCE_INVALID"),
    4: .same(proto: "PRECONDITION_FAILURE_TYPE_SECURITY_LEVEL_INSUFFICIENT"),
  ]
}
