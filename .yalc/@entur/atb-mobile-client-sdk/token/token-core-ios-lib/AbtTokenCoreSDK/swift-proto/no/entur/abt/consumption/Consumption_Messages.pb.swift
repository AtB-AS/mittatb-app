// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: no/entur/abt/consumption/Consumption_Messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// /home/circleci/project/protobuf-reduced-traveller/target/proto_deps/no/entur/abt/consumption/Consumption_Messages.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Result type for a request to consume something without specifying the details of what
enum No_Entur_Abt_Core_V1_AutoConsumeFareContractStatusType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Default; (no) value
  case unspecified // = 0

  /// At least one CustomerPurchasePackageElement was consumed
  case consumed // = 1

  /// No CustomerPurchasePackageElements was consumable for request
  case noConsumableElements // = 2

  /// More than one CustomerPurchasePackageElements was consumable for request
  case ambiguousElement // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .consumed
    case 2: self = .noConsumableElements
    case 3: self = .ambiguousElement
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .consumed: return 1
    case .noConsumableElements: return 2
    case .ambiguousElement: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension No_Entur_Abt_Core_V1_AutoConsumeFareContractStatusType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [No_Entur_Abt_Core_V1_AutoConsumeFareContractStatusType] = [
    .unspecified,
    .consumed,
    .noConsumableElements,
    .ambiguousElement,
  ]
}

#endif  // swift(>=4.2)

/// Specification of CustomerPurchasePackageElement requested to be consumed
struct No_Entur_Abt_Core_V1_CustomerPurchasePackageElementConsumptionSpecification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The customer purchase package elements to consume
  var customerPurchasePackageElementRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _customerPurchasePackageElementRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_customerPurchasePackageElementRef = newValue}
  }
  /// Returns true if `customerPurchasePackageElementRef` has been explicitly set.
  var hasCustomerPurchasePackageElementRef: Bool {return self._customerPurchasePackageElementRef != nil}
  /// Clears the value of `customerPurchasePackageElementRef`. Subsequent reads from it will return its default value.
  mutating func clearCustomerPurchasePackageElementRef() {self._customerPurchasePackageElementRef = nil}

  /// Relevant specifications to consume the element
  var consumptionSpecification: No_Entur_Abt_Core_V1_ConsumptionSpecification {
    get {return _consumptionSpecification ?? No_Entur_Abt_Core_V1_ConsumptionSpecification()}
    set {_consumptionSpecification = newValue}
  }
  /// Returns true if `consumptionSpecification` has been explicitly set.
  var hasConsumptionSpecification: Bool {return self._consumptionSpecification != nil}
  /// Clears the value of `consumptionSpecification`. Subsequent reads from it will return its default value.
  mutating func clearConsumptionSpecification() {self._consumptionSpecification = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _customerPurchasePackageElementRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil
  fileprivate var _consumptionSpecification: No_Entur_Abt_Core_V1_ConsumptionSpecification? = nil
}

/// Specifications for a request for consumption
struct No_Entur_Abt_Core_V1_ConsumptionSpecification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specified start time, only applicable if consumed PolicyAssignment contains SpecificationStartTimePolicyAssignment
  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {self._startTime = nil}

  /// Specification validity params, must match SpecificationXXXPolicyAssignment on CustomerPurchasePackageElement to be activated
  var validityParameters: Uk_Org_Netex_Www_Netex_ValidityParameters_RelStructure {
    get {return _validityParameters ?? Uk_Org_Netex_Www_Netex_ValidityParameters_RelStructure()}
    set {_validityParameters = newValue}
  }
  /// Returns true if `validityParameters` has been explicitly set.
  var hasValidityParameters: Bool {return self._validityParameters != nil}
  /// Clears the value of `validityParameters`. Subsequent reads from it will return its default value.
  mutating func clearValidityParameters() {self._validityParameters = nil}

  /// Flag to allow parallel consumption, ie that validity period for new element access overlaps with other
  /// existing/consumed in same command element access. This should only be set when traveller should have access rights for multiple travellers, for instance a carnet consumed to allow two travellers.
  var allowParallelConsumption: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _validityParameters: Uk_Org_Netex_Www_Netex_ValidityParameters_RelStructure? = nil
}

struct No_Entur_Abt_Core_V1_ConsumableCustomerPurchasePackageElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ref to the consumable CustomerPurchasePackageElement
  var customerPurchasePackageElementRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _storage._customerPurchasePackageElementRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_uniqueStorage()._customerPurchasePackageElementRef = newValue}
  }
  /// Returns true if `customerPurchasePackageElementRef` has been explicitly set.
  var hasCustomerPurchasePackageElementRef: Bool {return _storage._customerPurchasePackageElementRef != nil}
  /// Clears the value of `customerPurchasePackageElementRef`. Subsequent reads from it will return its default value.
  mutating func clearCustomerPurchasePackageElementRef() {_uniqueStorage()._customerPurchasePackageElementRef = nil}

  /// The current markedAs status for the element
  var currentMarkedAs: Uk_Org_Netex_Www_Netex_MarkedAsEnumeration {
    get {return _storage._currentMarkedAs}
    set {_uniqueStorage()._currentMarkedAs = newValue}
  }

  /// The markedAs status the element will change to if consumed according to this description
  var potentialMarkedAs: Uk_Org_Netex_Www_Netex_MarkedAsEnumeration {
    get {return _storage._potentialMarkedAs}
    set {_uniqueStorage()._potentialMarkedAs = newValue}
  }

  /// Description of required specification policy assignments to consume element according to this description. Indicates which specification_validity_parameters_refs is required in the ConsumptionSpecification
  var requiredSpecificationPolicyAssignments: [Uk_Org_Netex_Www_Netex_CustomerPurchaseParameterAssignmentType] {
    get {return _storage._requiredSpecificationPolicyAssignments}
    set {_uniqueStorage()._requiredSpecificationPolicyAssignments = newValue}
  }

  /// Description of the usage validity period for consumption, including period, activationMeans and usageTrigger
  var usageValidityPeriod: Uk_Org_Netex_Www_Netex_UsageValidityPeriodType {
    get {return _storage._usageValidityPeriod ?? Uk_Org_Netex_Www_Netex_UsageValidityPeriodType()}
    set {_uniqueStorage()._usageValidityPeriod = newValue}
  }
  /// Returns true if `usageValidityPeriod` has been explicitly set.
  var hasUsageValidityPeriod: Bool {return _storage._usageValidityPeriod != nil}
  /// Clears the value of `usageValidityPeriod`. Subsequent reads from it will return its default value.
  mutating func clearUsageValidityPeriod() {_uniqueStorage()._usageValidityPeriod = nil}

  /// Fare demand factor restricting when this element can be consumed according to this description.
  var fareDemandFactorRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _storage._fareDemandFactorRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_uniqueStorage()._fareDemandFactorRef = newValue}
  }
  /// Returns true if `fareDemandFactorRef` has been explicitly set.
  var hasFareDemandFactorRef: Bool {return _storage._fareDemandFactorRef != nil}
  /// Clears the value of `fareDemandFactorRef`. Subsequent reads from it will return its default value.
  mutating func clearFareDemandFactorRef() {_uniqueStorage()._fareDemandFactorRef = nil}

  /// Remaining number of accesses of this element according to this description (assuming no other consumption occurs)
  var remainingNumberOfAccesses: Uk_Org_Netex_Www_Netex_MaximumNumberOfAccessesType {
    get {return _storage._remainingNumberOfAccesses ?? Uk_Org_Netex_Www_Netex_MaximumNumberOfAccessesType()}
    set {_uniqueStorage()._remainingNumberOfAccesses = newValue}
  }
  /// Returns true if `remainingNumberOfAccesses` has been explicitly set.
  var hasRemainingNumberOfAccesses: Bool {return _storage._remainingNumberOfAccesses != nil}
  /// Clears the value of `remainingNumberOfAccesses`. Subsequent reads from it will return its default value.
  mutating func clearRemainingNumberOfAccesses() {_uniqueStorage()._remainingNumberOfAccesses = nil}

  /// Whether consuming at given time requires allow_parallel_consumption to be set to true.
  /// Will only be true if access rights allows multiple simultaneous travellers and already consumed for at least one traveller.
  var requiresParallelConsumption: Bool {
    get {return _storage._requiresParallelConsumption}
    set {_uniqueStorage()._requiresParallelConsumption = newValue}
  }

  /// Ref to the FareContract containing the CustomerPurchasePackageElement
  var fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _storage._fareContractRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_uniqueStorage()._fareContractRef = newValue}
  }
  /// Returns true if `fareContractRef` has been explicitly set.
  var hasFareContractRef: Bool {return _storage._fareContractRef != nil}
  /// Clears the value of `fareContractRef`. Subsequent reads from it will return its default value.
  mutating func clearFareContractRef() {_uniqueStorage()._fareContractRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// List of consumable CustomerPurchasePackageElements for a fare contract
struct No_Entur_Abt_Core_V1_ConsumableCustomerPurchasePackageElementsForFareContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fare contract containing the CustomerPurchasePackageElements
  var fareContract: Uk_Org_Netex_Www_Netex_FareContractType {
    get {return _fareContract ?? Uk_Org_Netex_Www_Netex_FareContractType()}
    set {_fareContract = newValue}
  }
  /// Returns true if `fareContract` has been explicitly set.
  var hasFareContract: Bool {return self._fareContract != nil}
  /// Clears the value of `fareContract`. Subsequent reads from it will return its default value.
  mutating func clearFareContract() {self._fareContract = nil}

  /// Elements still eligible for consumption for this fare contract
  var consumableElements: [No_Entur_Abt_Core_V1_ConsumableCustomerPurchasePackageElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fareContract: Uk_Org_Netex_Www_Netex_FareContractType? = nil
}

/// Wrapper around the different types of identifiers for a customer account (either customer_account_id or token_identification required)
struct No_Entur_Abt_Core_V1_CustomerAccountIdentification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var content: No_Entur_Abt_Core_V1_CustomerAccountIdentification.OneOf_Content? = nil

  var customerAccountID: String {
    get {
      if case .customerAccountID(let v)? = content {return v}
      return String()
    }
    set {content = .customerAccountID(newValue)}
  }

  /// Identification of the token
  var tokenIdentification: No_Entur_Abt_Core_V1_TokenIdentification {
    get {
      if case .tokenIdentification(let v)? = content {return v}
      return No_Entur_Abt_Core_V1_TokenIdentification()
    }
    set {content = .tokenIdentification(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case customerAccountID(String)
    /// Identification of the token
    case tokenIdentification(No_Entur_Abt_Core_V1_TokenIdentification)

  #if !swift(>=4.1)
    static func ==(lhs: No_Entur_Abt_Core_V1_CustomerAccountIdentification.OneOf_Content, rhs: No_Entur_Abt_Core_V1_CustomerAccountIdentification.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.customerAccountID, .customerAccountID): return {
        guard case .customerAccountID(let l) = lhs, case .customerAccountID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenIdentification, .tokenIdentification): return {
        guard case .tokenIdentification(let l) = lhs, case .tokenIdentification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Reference to a CustomerPurchasePackageElement in a specific FareContract
struct No_Entur_Abt_Core_V1_CustomerPurchasePackageElementInFareContractRef {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to the fare contract containing the CustomerPurchasePackageElement
  var fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _fareContractRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_fareContractRef = newValue}
  }
  /// Returns true if `fareContractRef` has been explicitly set.
  var hasFareContractRef: Bool {return self._fareContractRef != nil}
  /// Clears the value of `fareContractRef`. Subsequent reads from it will return its default value.
  mutating func clearFareContractRef() {self._fareContractRef = nil}

  /// Reference to the specific customer purchase package element
  var customerPurchasePackageElementRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _customerPurchasePackageElementRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_customerPurchasePackageElementRef = newValue}
  }
  /// Returns true if `customerPurchasePackageElementRef` has been explicitly set.
  var hasCustomerPurchasePackageElementRef: Bool {return self._customerPurchasePackageElementRef != nil}
  /// Clears the value of `customerPurchasePackageElementRef`. Subsequent reads from it will return its default value.
  mutating func clearCustomerPurchasePackageElementRef() {self._customerPurchasePackageElementRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil
  fileprivate var _customerPurchasePackageElementRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil
}

/// Request to consume CustomerPurchasePackageElements for use with library function
struct No_Entur_Abt_Core_V1_ConsumeCustomerPurchasePackageElementsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fare contract to consume
  var fareContract: Uk_Org_Netex_Www_Netex_FareContractType {
    get {return _fareContract ?? Uk_Org_Netex_Www_Netex_FareContractType()}
    set {_fareContract = newValue}
  }
  /// Returns true if `fareContract` has been explicitly set.
  var hasFareContract: Bool {return self._fareContract != nil}
  /// Clears the value of `fareContract`. Subsequent reads from it will return its default value.
  mutating func clearFareContract() {self._fareContract = nil}

  /// Time when consumption occurred
  var consumptionTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _consumptionTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_consumptionTime = newValue}
  }
  /// Returns true if `consumptionTime` has been explicitly set.
  var hasConsumptionTime: Bool {return self._consumptionTime != nil}
  /// Clears the value of `consumptionTime`. Subsequent reads from it will return its default value.
  mutating func clearConsumptionTime() {self._consumptionTime = nil}

  /// Means of activation.
  /// TicketInspection should specify USE_OF_VALIDATOR for now. There will probably be introduced a more specific value for authorized personnel at a later time.
  var activationMeans: Uk_Org_Netex_Www_Netex_ActivationMeansEnumeration = .unspecified

  /// The control parameters describing requirements and context if this consumption was triggered by validation
  var controlParameters: Uk_Org_Netex_Www_Netex_ControlParametersType {
    get {return _controlParameters ?? Uk_Org_Netex_Www_Netex_ControlParametersType()}
    set {_controlParameters = newValue}
  }
  /// Returns true if `controlParameters` has been explicitly set.
  var hasControlParameters: Bool {return self._controlParameters != nil}
  /// Clears the value of `controlParameters`. Subsequent reads from it will return its default value.
  mutating func clearControlParameters() {self._controlParameters = nil}

  /// Consumption specifications for one or more specified CustomerPurchasePackageElements.
  var elementConsumptionSpecifications: [No_Entur_Abt_Core_V1_CustomerPurchasePackageElementConsumptionSpecification] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fareContract: Uk_Org_Netex_Www_Netex_FareContractType? = nil
  fileprivate var _consumptionTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _controlParameters: Uk_Org_Netex_Www_Netex_ControlParametersType? = nil
}

/// Request to revalidate CustomerPurchasePackageElements for use with library function
struct No_Entur_Abt_Core_V1_RevalidateCustomerPurchasePackageElementRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fare contract to consume
  var fareContract: Uk_Org_Netex_Www_Netex_FareContractType {
    get {return _fareContract ?? Uk_Org_Netex_Www_Netex_FareContractType()}
    set {_fareContract = newValue}
  }
  /// Returns true if `fareContract` has been explicitly set.
  var hasFareContract: Bool {return self._fareContract != nil}
  /// Clears the value of `fareContract`. Subsequent reads from it will return its default value.
  mutating func clearFareContract() {self._fareContract = nil}

  /// Means of activation.
  /// TicketInspection should specify USE_OF_VALIDATOR for now. There will probably be introduced a more specific value for authorized personnel at a later time.
  var activationMeans: Uk_Org_Netex_Www_Netex_ActivationMeansEnumeration = .unspecified

  /// The control parameters describing requirements and context
  var controlParameters: Uk_Org_Netex_Www_Netex_ControlParametersType {
    get {return _controlParameters ?? Uk_Org_Netex_Www_Netex_ControlParametersType()}
    set {_controlParameters = newValue}
  }
  /// Returns true if `controlParameters` has been explicitly set.
  var hasControlParameters: Bool {return self._controlParameters != nil}
  /// Clears the value of `controlParameters`. Subsequent reads from it will return its default value.
  mutating func clearControlParameters() {self._controlParameters = nil}

  /// Consumption specifications for one or more specified CustomerPurchasePackageElements.
  var elementRevalidationSpecification: No_Entur_Abt_Core_V1_CustomerPurchasePackageElementRevalidationSpecification {
    get {return _elementRevalidationSpecification ?? No_Entur_Abt_Core_V1_CustomerPurchasePackageElementRevalidationSpecification()}
    set {_elementRevalidationSpecification = newValue}
  }
  /// Returns true if `elementRevalidationSpecification` has been explicitly set.
  var hasElementRevalidationSpecification: Bool {return self._elementRevalidationSpecification != nil}
  /// Clears the value of `elementRevalidationSpecification`. Subsequent reads from it will return its default value.
  mutating func clearElementRevalidationSpecification() {self._elementRevalidationSpecification = nil}

  /// Instructions on on how to determine whether revalidation should be allowed
  var revalidationPolicy: No_Entur_Abt_Core_V1_RevalidationPolicy {
    get {return _revalidationPolicy ?? No_Entur_Abt_Core_V1_RevalidationPolicy()}
    set {_revalidationPolicy = newValue}
  }
  /// Returns true if `revalidationPolicy` has been explicitly set.
  var hasRevalidationPolicy: Bool {return self._revalidationPolicy != nil}
  /// Clears the value of `revalidationPolicy`. Subsequent reads from it will return its default value.
  mutating func clearRevalidationPolicy() {self._revalidationPolicy = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fareContract: Uk_Org_Netex_Www_Netex_FareContractType? = nil
  fileprivate var _controlParameters: Uk_Org_Netex_Www_Netex_ControlParametersType? = nil
  fileprivate var _elementRevalidationSpecification: No_Entur_Abt_Core_V1_CustomerPurchasePackageElementRevalidationSpecification? = nil
  fileprivate var _revalidationPolicy: No_Entur_Abt_Core_V1_RevalidationPolicy? = nil
}

/// Specification of CustomerPurchasePackageElement requested to be revalidated
struct No_Entur_Abt_Core_V1_CustomerPurchasePackageElementRevalidationSpecification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The customer purchase package elements to revalidate
  var customerPurchasePackageElementRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _customerPurchasePackageElementRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_customerPurchasePackageElementRef = newValue}
  }
  /// Returns true if `customerPurchasePackageElementRef` has been explicitly set.
  var hasCustomerPurchasePackageElementRef: Bool {return self._customerPurchasePackageElementRef != nil}
  /// Clears the value of `customerPurchasePackageElementRef`. Subsequent reads from it will return its default value.
  mutating func clearCustomerPurchasePackageElementRef() {self._customerPurchasePackageElementRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _customerPurchasePackageElementRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil
}

/// Instructions on on how to determine whether revalidation should be allowed
struct No_Entur_Abt_Core_V1_RevalidationPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of seconds after previous consumption/revalidation that element may NOT be revalidated with same parameters (same validator/stop place/quay/service journey/dme). To avoid pass back, ie same access rights used by multiple travellers
  var rejectDuplicatesWindowSeconds: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension No_Entur_Abt_Core_V1_AutoConsumeFareContractStatusType: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_CustomerPurchasePackageElementConsumptionSpecification: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_ConsumptionSpecification: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_ConsumableCustomerPurchasePackageElement: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_ConsumableCustomerPurchasePackageElementsForFareContract: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_CustomerAccountIdentification: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_CustomerAccountIdentification.OneOf_Content: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_CustomerPurchasePackageElementInFareContractRef: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_ConsumeCustomerPurchasePackageElementsRequest: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_RevalidateCustomerPurchasePackageElementRequest: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_CustomerPurchasePackageElementRevalidationSpecification: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_RevalidationPolicy: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "no.entur.abt.core.v1"

extension No_Entur_Abt_Core_V1_AutoConsumeFareContractStatusType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTO_CONSUME_FARE_CONTRACT_STATUS_TYPE_UNSPECIFIED"),
    1: .same(proto: "AUTO_CONSUME_FARE_CONTRACT_STATUS_TYPE_CONSUMED"),
    2: .same(proto: "AUTO_CONSUME_FARE_CONTRACT_STATUS_TYPE_NO_CONSUMABLE_ELEMENTS"),
    3: .same(proto: "AUTO_CONSUME_FARE_CONTRACT_STATUS_TYPE_AMBIGUOUS_ELEMENT"),
  ]
}

extension No_Entur_Abt_Core_V1_CustomerPurchasePackageElementConsumptionSpecification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CustomerPurchasePackageElementConsumptionSpecification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "customer_purchase_package_element_ref"),
    2: .standard(proto: "consumption_specification"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._customerPurchasePackageElementRef) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._consumptionSpecification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._customerPurchasePackageElementRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._consumptionSpecification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_CustomerPurchasePackageElementConsumptionSpecification, rhs: No_Entur_Abt_Core_V1_CustomerPurchasePackageElementConsumptionSpecification) -> Bool {
    if lhs._customerPurchasePackageElementRef != rhs._customerPurchasePackageElementRef {return false}
    if lhs._consumptionSpecification != rhs._consumptionSpecification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_ConsumptionSpecification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConsumptionSpecification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "start_time"),
    4: .standard(proto: "validity_parameters"),
    3: .standard(proto: "allow_parallel_consumption"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allowParallelConsumption) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._validityParameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.allowParallelConsumption != false {
      try visitor.visitSingularBoolField(value: self.allowParallelConsumption, fieldNumber: 3)
    }
    try { if let v = self._validityParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_ConsumptionSpecification, rhs: No_Entur_Abt_Core_V1_ConsumptionSpecification) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._validityParameters != rhs._validityParameters {return false}
    if lhs.allowParallelConsumption != rhs.allowParallelConsumption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_ConsumableCustomerPurchasePackageElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConsumableCustomerPurchasePackageElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "customer_purchase_package_element_ref"),
    2: .standard(proto: "current_marked_as"),
    3: .standard(proto: "potential_marked_as"),
    4: .standard(proto: "required_specification_policy_assignments"),
    5: .standard(proto: "usage_validity_period"),
    6: .standard(proto: "fare_demand_factor_ref"),
    7: .standard(proto: "remaining_number_of_accesses"),
    8: .standard(proto: "requires_parallel_consumption"),
    9: .standard(proto: "fare_contract_ref"),
  ]

  fileprivate class _StorageClass {
    var _customerPurchasePackageElementRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil
    var _currentMarkedAs: Uk_Org_Netex_Www_Netex_MarkedAsEnumeration = .unspecified
    var _potentialMarkedAs: Uk_Org_Netex_Www_Netex_MarkedAsEnumeration = .unspecified
    var _requiredSpecificationPolicyAssignments: [Uk_Org_Netex_Www_Netex_CustomerPurchaseParameterAssignmentType] = []
    var _usageValidityPeriod: Uk_Org_Netex_Www_Netex_UsageValidityPeriodType? = nil
    var _fareDemandFactorRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil
    var _remainingNumberOfAccesses: Uk_Org_Netex_Www_Netex_MaximumNumberOfAccessesType? = nil
    var _requiresParallelConsumption: Bool = false
    var _fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _customerPurchasePackageElementRef = source._customerPurchasePackageElementRef
      _currentMarkedAs = source._currentMarkedAs
      _potentialMarkedAs = source._potentialMarkedAs
      _requiredSpecificationPolicyAssignments = source._requiredSpecificationPolicyAssignments
      _usageValidityPeriod = source._usageValidityPeriod
      _fareDemandFactorRef = source._fareDemandFactorRef
      _remainingNumberOfAccesses = source._remainingNumberOfAccesses
      _requiresParallelConsumption = source._requiresParallelConsumption
      _fareContractRef = source._fareContractRef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._customerPurchasePackageElementRef) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._currentMarkedAs) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._potentialMarkedAs) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._requiredSpecificationPolicyAssignments) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._usageValidityPeriod) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._fareDemandFactorRef) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._remainingNumberOfAccesses) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._requiresParallelConsumption) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._fareContractRef) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._customerPurchasePackageElementRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._currentMarkedAs != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._currentMarkedAs, fieldNumber: 2)
      }
      if _storage._potentialMarkedAs != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._potentialMarkedAs, fieldNumber: 3)
      }
      if !_storage._requiredSpecificationPolicyAssignments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requiredSpecificationPolicyAssignments, fieldNumber: 4)
      }
      try { if let v = _storage._usageValidityPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._fareDemandFactorRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._remainingNumberOfAccesses {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._requiresParallelConsumption != false {
        try visitor.visitSingularBoolField(value: _storage._requiresParallelConsumption, fieldNumber: 8)
      }
      try { if let v = _storage._fareContractRef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_ConsumableCustomerPurchasePackageElement, rhs: No_Entur_Abt_Core_V1_ConsumableCustomerPurchasePackageElement) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._customerPurchasePackageElementRef != rhs_storage._customerPurchasePackageElementRef {return false}
        if _storage._currentMarkedAs != rhs_storage._currentMarkedAs {return false}
        if _storage._potentialMarkedAs != rhs_storage._potentialMarkedAs {return false}
        if _storage._requiredSpecificationPolicyAssignments != rhs_storage._requiredSpecificationPolicyAssignments {return false}
        if _storage._usageValidityPeriod != rhs_storage._usageValidityPeriod {return false}
        if _storage._fareDemandFactorRef != rhs_storage._fareDemandFactorRef {return false}
        if _storage._remainingNumberOfAccesses != rhs_storage._remainingNumberOfAccesses {return false}
        if _storage._requiresParallelConsumption != rhs_storage._requiresParallelConsumption {return false}
        if _storage._fareContractRef != rhs_storage._fareContractRef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_ConsumableCustomerPurchasePackageElementsForFareContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConsumableCustomerPurchasePackageElementsForFareContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fare_contract"),
    2: .standard(proto: "consumable_elements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fareContract) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.consumableElements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fareContract {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.consumableElements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.consumableElements, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_ConsumableCustomerPurchasePackageElementsForFareContract, rhs: No_Entur_Abt_Core_V1_ConsumableCustomerPurchasePackageElementsForFareContract) -> Bool {
    if lhs._fareContract != rhs._fareContract {return false}
    if lhs.consumableElements != rhs.consumableElements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_CustomerAccountIdentification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CustomerAccountIdentification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "customer_account_id"),
    2: .standard(proto: "token_identification"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .customerAccountID(v)
        }
      }()
      case 2: try {
        var v: No_Entur_Abt_Core_V1_TokenIdentification?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .tokenIdentification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .tokenIdentification(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .customerAccountID?: try {
      guard case .customerAccountID(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .tokenIdentification?: try {
      guard case .tokenIdentification(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_CustomerAccountIdentification, rhs: No_Entur_Abt_Core_V1_CustomerAccountIdentification) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_CustomerPurchasePackageElementInFareContractRef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CustomerPurchasePackageElementInFareContractRef"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fare_contract_ref"),
    2: .standard(proto: "customer_purchase_package_element_ref"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fareContractRef) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._customerPurchasePackageElementRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fareContractRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._customerPurchasePackageElementRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_CustomerPurchasePackageElementInFareContractRef, rhs: No_Entur_Abt_Core_V1_CustomerPurchasePackageElementInFareContractRef) -> Bool {
    if lhs._fareContractRef != rhs._fareContractRef {return false}
    if lhs._customerPurchasePackageElementRef != rhs._customerPurchasePackageElementRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_ConsumeCustomerPurchasePackageElementsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConsumeCustomerPurchasePackageElementsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "fare_contract"),
    3: .standard(proto: "consumption_time"),
    4: .standard(proto: "activation_means"),
    5: .standard(proto: "control_parameters"),
    6: .standard(proto: "element_consumption_specifications"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fareContract) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._consumptionTime) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.activationMeans) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._controlParameters) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.elementConsumptionSpecifications) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fareContract {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._consumptionTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.activationMeans != .unspecified {
      try visitor.visitSingularEnumField(value: self.activationMeans, fieldNumber: 4)
    }
    try { if let v = self._controlParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.elementConsumptionSpecifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elementConsumptionSpecifications, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_ConsumeCustomerPurchasePackageElementsRequest, rhs: No_Entur_Abt_Core_V1_ConsumeCustomerPurchasePackageElementsRequest) -> Bool {
    if lhs._fareContract != rhs._fareContract {return false}
    if lhs._consumptionTime != rhs._consumptionTime {return false}
    if lhs.activationMeans != rhs.activationMeans {return false}
    if lhs._controlParameters != rhs._controlParameters {return false}
    if lhs.elementConsumptionSpecifications != rhs.elementConsumptionSpecifications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_RevalidateCustomerPurchasePackageElementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevalidateCustomerPurchasePackageElementRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fare_contract"),
    2: .standard(proto: "activation_means"),
    3: .standard(proto: "control_parameters"),
    4: .standard(proto: "element_revalidation_specification"),
    6: .standard(proto: "revalidation_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fareContract) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.activationMeans) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._controlParameters) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._elementRevalidationSpecification) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._revalidationPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fareContract {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.activationMeans != .unspecified {
      try visitor.visitSingularEnumField(value: self.activationMeans, fieldNumber: 2)
    }
    try { if let v = self._controlParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._elementRevalidationSpecification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._revalidationPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_RevalidateCustomerPurchasePackageElementRequest, rhs: No_Entur_Abt_Core_V1_RevalidateCustomerPurchasePackageElementRequest) -> Bool {
    if lhs._fareContract != rhs._fareContract {return false}
    if lhs.activationMeans != rhs.activationMeans {return false}
    if lhs._controlParameters != rhs._controlParameters {return false}
    if lhs._elementRevalidationSpecification != rhs._elementRevalidationSpecification {return false}
    if lhs._revalidationPolicy != rhs._revalidationPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_CustomerPurchasePackageElementRevalidationSpecification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CustomerPurchasePackageElementRevalidationSpecification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "customer_purchase_package_element_ref"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._customerPurchasePackageElementRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._customerPurchasePackageElementRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_CustomerPurchasePackageElementRevalidationSpecification, rhs: No_Entur_Abt_Core_V1_CustomerPurchasePackageElementRevalidationSpecification) -> Bool {
    if lhs._customerPurchasePackageElementRef != rhs._customerPurchasePackageElementRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_RevalidationPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevalidationPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reject_duplicates_window_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.rejectDuplicatesWindowSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rejectDuplicatesWindowSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.rejectDuplicatesWindowSeconds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_RevalidationPolicy, rhs: No_Entur_Abt_Core_V1_RevalidationPolicy) -> Bool {
    if lhs.rejectDuplicatesWindowSeconds != rhs.rejectDuplicatesWindowSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
