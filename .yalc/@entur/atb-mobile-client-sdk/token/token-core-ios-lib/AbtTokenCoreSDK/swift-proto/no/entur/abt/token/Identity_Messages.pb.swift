// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: no/entur/abt/token/Identity_Messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// /home/circleci/project/protobuf-reduced-traveller/target/proto_deps/no/entur/abt/token/Identity_Messages.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Defines status of TokenIdentity
enum No_Entur_Abt_Core_V1_TokenIdentityStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Default; (no) value
  case unspecified // = 0

  /// Token was identified
  case ok // = 1

  /// Token was not known
  case notFound // = 2

  /// Token is not valid
  case invalid // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .ok
    case 2: self = .notFound
    case 3: self = .invalid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .ok: return 1
    case .notFound: return 2
    case .invalid: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension No_Entur_Abt_Core_V1_TokenIdentityStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [No_Entur_Abt_Core_V1_TokenIdentityStatus] = [
    .unspecified,
    .ok,
    .notFound,
    .invalid,
  ]
}

#endif  // swift(>=4.2)

enum No_Entur_Abt_Core_V1_TokenStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Value is not set
  case unspecified // = 0

  /// Token is valid
  case valid // = 1

  /// Token has been marked as inactive
  case markedInactive // = 2

  /// Token is not yet valid
  case validityNotStarted // = 3

  /// Token is no longer valid
  case validityEnded // = 4

  /// Token was not found
  case notFound // = 5

  /// Type provided in encoded token does not match registered type for token
  case typeMismatch // = 6

  /// Certificate does belong to token
  case certificateMismatch // = 7

  /// Actions in encoded token does not match required actions for usage
  case actionsMismatch // = 8

  /// Encoded token has clock skew more than allowed limit
  case clockSkew // = 9

  /// The signature does match signed payload for expected key
  case signatureInvalid // = 10

  /// Certificate provided in encoded token is not valid
  case certificateInvalid // = 11

  /// Local token was rejected as invalid by issuer
  case localTokenInvalid // = 12

  /// Device info in encoded token did not match DeviceInfo registered for Token. Token must be renewed
  case deviceInfoMismatch // = 13

  /// Token does not allow required actions
  case actionsNotAllowed // = 14

  /// Token type is not allowed to operation
  case typeNotAllowed // = 15

  /// Encoded token format is invalid
  case encodingFormatInvalid // = 16
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .valid
    case 2: self = .markedInactive
    case 3: self = .validityNotStarted
    case 4: self = .validityEnded
    case 5: self = .notFound
    case 6: self = .typeMismatch
    case 7: self = .certificateMismatch
    case 8: self = .actionsMismatch
    case 9: self = .clockSkew
    case 10: self = .signatureInvalid
    case 11: self = .certificateInvalid
    case 12: self = .localTokenInvalid
    case 13: self = .deviceInfoMismatch
    case 14: self = .actionsNotAllowed
    case 15: self = .typeNotAllowed
    case 16: self = .encodingFormatInvalid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .valid: return 1
    case .markedInactive: return 2
    case .validityNotStarted: return 3
    case .validityEnded: return 4
    case .notFound: return 5
    case .typeMismatch: return 6
    case .certificateMismatch: return 7
    case .actionsMismatch: return 8
    case .clockSkew: return 9
    case .signatureInvalid: return 10
    case .certificateInvalid: return 11
    case .localTokenInvalid: return 12
    case .deviceInfoMismatch: return 13
    case .actionsNotAllowed: return 14
    case .typeNotAllowed: return 15
    case .encodingFormatInvalid: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension No_Entur_Abt_Core_V1_TokenStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [No_Entur_Abt_Core_V1_TokenStatus] = [
    .unspecified,
    .valid,
    .markedInactive,
    .validityNotStarted,
    .validityEnded,
    .notFound,
    .typeMismatch,
    .certificateMismatch,
    .actionsMismatch,
    .clockSkew,
    .signatureInvalid,
    .certificateInvalid,
    .localTokenInvalid,
    .deviceInfoMismatch,
    .actionsNotAllowed,
    .typeNotAllowed,
    .encodingFormatInvalid,
  ]
}

#endif  // swift(>=4.2)

struct No_Entur_Abt_Core_V1_TokenIdentification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// How to relate to token identification potentially mapping to multiple customer accounts. By the time of writing, this can happen only with EMV tokens. So far single_account_only as the default behaviour. By the time of writing, all operations don't support multi-token options
  var multiCustomerAccountStrategy: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy {
    get {return _multiCustomerAccountStrategy ?? No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy()}
    set {_multiCustomerAccountStrategy = newValue}
  }
  /// Returns true if `multiCustomerAccountStrategy` has been explicitly set.
  var hasMultiCustomerAccountStrategy: Bool {return self._multiCustomerAccountStrategy != nil}
  /// Clears the value of `multiCustomerAccountStrategy`. Subsequent reads from it will return its default value.
  mutating func clearMultiCustomerAccountStrategy() {self._multiCustomerAccountStrategy = nil}

  var content: No_Entur_Abt_Core_V1_TokenIdentification.OneOf_Content? = nil

  /// Token encoded in a secure container
  var secureContainerToken: No_Entur_Abt_Core_V1_SecureContainer {
    get {
      if case .secureContainerToken(let v)? = content {return v}
      return No_Entur_Abt_Core_V1_SecureContainer()
    }
    set {content = .secureContainerToken(newValue)}
  }

  /// Token identified by token id
  var tokenIdentifier: No_Entur_Abt_Core_V1_TokenIdentifier {
    get {
      if case .tokenIdentifier(let v)? = content {return v}
      return No_Entur_Abt_Core_V1_TokenIdentifier()
    }
    set {content = .tokenIdentifier(newValue)}
  }

  /// Identifier for travel card acting as token
  var nodTravelCardIdentifier: No_Entur_Abt_Core_V1_NodTravelCardIdentifier {
    get {
      if case .nodTravelCardIdentifier(let v)? = content {return v}
      return No_Entur_Abt_Core_V1_NodTravelCardIdentifier()
    }
    set {content = .nodTravelCardIdentifier(newValue)}
  }

  /// Identifier for reference code token
  var referenceCodeIDToken: No_Entur_Abt_Core_V1_ReferenceCodeIdToken {
    get {
      if case .referenceCodeIDToken(let v)? = content {return v}
      return No_Entur_Abt_Core_V1_ReferenceCodeIdToken()
    }
    set {content = .referenceCodeIDToken(newValue)}
  }

  /// Identifier for local Id token
  var localIDToken: No_Entur_Abt_Core_V1_LocalIDToken {
    get {
      if case .localIDToken(let v)? = content {return v}
      return No_Entur_Abt_Core_V1_LocalIDToken()
    }
    set {content = .localIDToken(newValue)}
  }

  /// Identifier for EMV payment card or a digital tokenized version as a token
  var emvIDToken: No_Entur_Abt_Core_V1_EMVIdToken {
    get {
      if case .emvIDToken(let v)? = content {return v}
      return No_Entur_Abt_Core_V1_EMVIdToken()
    }
    set {content = .emvIDToken(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    /// Token encoded in a secure container
    case secureContainerToken(No_Entur_Abt_Core_V1_SecureContainer)
    /// Token identified by token id
    case tokenIdentifier(No_Entur_Abt_Core_V1_TokenIdentifier)
    /// Identifier for travel card acting as token
    case nodTravelCardIdentifier(No_Entur_Abt_Core_V1_NodTravelCardIdentifier)
    /// Identifier for reference code token
    case referenceCodeIDToken(No_Entur_Abt_Core_V1_ReferenceCodeIdToken)
    /// Identifier for local Id token
    case localIDToken(No_Entur_Abt_Core_V1_LocalIDToken)
    /// Identifier for EMV payment card or a digital tokenized version as a token
    case emvIDToken(No_Entur_Abt_Core_V1_EMVIdToken)

  #if !swift(>=4.1)
    static func ==(lhs: No_Entur_Abt_Core_V1_TokenIdentification.OneOf_Content, rhs: No_Entur_Abt_Core_V1_TokenIdentification.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.secureContainerToken, .secureContainerToken): return {
        guard case .secureContainerToken(let l) = lhs, case .secureContainerToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenIdentifier, .tokenIdentifier): return {
        guard case .tokenIdentifier(let l) = lhs, case .tokenIdentifier(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nodTravelCardIdentifier, .nodTravelCardIdentifier): return {
        guard case .nodTravelCardIdentifier(let l) = lhs, case .nodTravelCardIdentifier(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.referenceCodeIDToken, .referenceCodeIDToken): return {
        guard case .referenceCodeIDToken(let l) = lhs, case .referenceCodeIDToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localIDToken, .localIDToken): return {
        guard case .localIDToken(let l) = lhs, case .localIDToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.emvIDToken, .emvIDToken): return {
        guard case .emvIDToken(let l) = lhs, case .emvIDToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _multiCustomerAccountStrategy: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy? = nil
}

struct No_Entur_Abt_Core_V1_TokenIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The uuid of the token
  var tokenID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct No_Entur_Abt_Core_V1_NodTravelCardIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var travelCardID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct No_Entur_Abt_Core_V1_ReferenceCodeIdToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var referenceCode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct No_Entur_Abt_Core_V1_LocalIDToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var tokenContent: Data = Data()

  /// Any additional payload - unspecified
  var additionalPayload: Dictionary<String,Data> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct No_Entur_Abt_Core_V1_EMVIdToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Hash of ICC public key certificate
  var emvTransitToken: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Strategy for how to relate to token identification potentially mapping to multiple tokens and customer accounts. By the time of writing, this can happen only with EMV tokens and max one token per identifier per customer account codespace.
struct No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var strategy: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.OneOf_Strategy? = nil

  /// Only single account expected. Error if multiple accounts found for a token identification. So far this is as the default behaviour
  var singleAccountOnly: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountOnly {
    get {
      if case .singleAccountOnly(let v)? = strategy {return v}
      return No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountOnly()
    }
    set {strategy = .singleAccountOnly(newValue)}
  }

  /// Consider only customer accounts in given codespace. Error if multiple accounts within given codespace
  var singleAccountWithinFixedCodespaceOnly: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountWithinFixedCodespaceOnly {
    get {
      if case .singleAccountWithinFixedCodespaceOnly(let v)? = strategy {return v}
      return No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountWithinFixedCodespaceOnly()
    }
    set {strategy = .singleAccountWithinFixedCodespaceOnly(newValue)}
  }

  /// Multiple accounts expected (any codespace). Not supported yet all operations (esp. inspection/validation).
  var multipleAccountsAnyCodespace: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsAnyCodespace {
    get {
      if case .multipleAccountsAnyCodespace(let v)? = strategy {return v}
      return No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsAnyCodespace()
    }
    set {strategy = .multipleAccountsAnyCodespace(newValue)}
  }

  /// Multiple accounts expected as specified. Not supported yet all operations (esp. inspection/validation).
  var multipleAccountsWithinFixedCodespaces: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsWithinFixedCodespaces {
    get {
      if case .multipleAccountsWithinFixedCodespaces(let v)? = strategy {return v}
      return No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsWithinFixedCodespaces()
    }
    set {strategy = .multipleAccountsWithinFixedCodespaces(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Strategy: Equatable {
    /// Only single account expected. Error if multiple accounts found for a token identification. So far this is as the default behaviour
    case singleAccountOnly(No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountOnly)
    /// Consider only customer accounts in given codespace. Error if multiple accounts within given codespace
    case singleAccountWithinFixedCodespaceOnly(No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountWithinFixedCodespaceOnly)
    /// Multiple accounts expected (any codespace). Not supported yet all operations (esp. inspection/validation).
    case multipleAccountsAnyCodespace(No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsAnyCodespace)
    /// Multiple accounts expected as specified. Not supported yet all operations (esp. inspection/validation).
    case multipleAccountsWithinFixedCodespaces(No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsWithinFixedCodespaces)

  #if !swift(>=4.1)
    static func ==(lhs: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.OneOf_Strategy, rhs: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.OneOf_Strategy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.singleAccountOnly, .singleAccountOnly): return {
        guard case .singleAccountOnly(let l) = lhs, case .singleAccountOnly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.singleAccountWithinFixedCodespaceOnly, .singleAccountWithinFixedCodespaceOnly): return {
        guard case .singleAccountWithinFixedCodespaceOnly(let l) = lhs, case .singleAccountWithinFixedCodespaceOnly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multipleAccountsAnyCodespace, .multipleAccountsAnyCodespace): return {
        guard case .multipleAccountsAnyCodespace(let l) = lhs, case .multipleAccountsAnyCodespace(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multipleAccountsWithinFixedCodespaces, .multipleAccountsWithinFixedCodespaces): return {
        guard case .multipleAccountsWithinFixedCodespaces(let l) = lhs, case .multipleAccountsWithinFixedCodespaces(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Only single account expected
  struct SingleAccountOnly {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Consider only customer accounts in given codespace.
  struct SingleAccountWithinFixedCodespaceOnly {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Codespace to accept
    var codespace: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Not supported yet with all operations (esp. inspection/validation).
  struct MultipleAccountsAnyCodespace {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Not supported yet with all operations (esp. inspection/validation). Exact content might be updated later as needed
  struct MultipleAccountsWithinFixedCodespaces {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Codespaces to accept
    var codespaces: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct No_Entur_Abt_Core_V1_TokenIdentityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identification status. Only status=OK here indicates that token is currently valid for identification. See detailed status in identity for status=INVALID
  var status: No_Entur_Abt_Core_V1_TokenIdentityStatus = .unspecified

  /// Ids for token and customer account
  var identity: No_Entur_Abt_Core_V1_TokenIdentity {
    get {return _identity ?? No_Entur_Abt_Core_V1_TokenIdentity()}
    set {_identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  var hasIdentity: Bool {return self._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  mutating func clearIdentity() {self._identity = nil}

  /// Token status
  var tokenStatus: No_Entur_Abt_Core_V1_TokenStatus = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _identity: No_Entur_Abt_Core_V1_TokenIdentity? = nil
}

struct No_Entur_Abt_Core_V1_TokenIdentity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The uuid of the token
  var tokenID: String = String()

  var tokenLifecycleState: Uk_Org_Netex_Www_Netex_TokenLifecycleState = .unspecified

  var customerAccountID: String = String()

  /// Reference to fare contract if this token is only valid for a specific fareContract.
  var fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _fareContractRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_fareContractRef = newValue}
  }
  /// Returns true if `fareContractRef` has been explicitly set.
  var hasFareContractRef: Bool {return self._fareContractRef != nil}
  /// Clears the value of `fareContractRef`. Subsequent reads from it will return its default value.
  mutating func clearFareContractRef() {self._fareContractRef = nil}

  /// Token role
  var role: Uk_Org_Netex_Www_Netex_TokenRole = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension No_Entur_Abt_Core_V1_TokenIdentityStatus: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_TokenStatus: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_TokenIdentification: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_TokenIdentification.OneOf_Content: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_TokenIdentifier: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_NodTravelCardIdentifier: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_ReferenceCodeIdToken: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_LocalIDToken: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_EMVIdToken: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.OneOf_Strategy: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountOnly: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountWithinFixedCodespaceOnly: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsAnyCodespace: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsWithinFixedCodespaces: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_TokenIdentityResponse: @unchecked Sendable {}
extension No_Entur_Abt_Core_V1_TokenIdentity: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "no.entur.abt.core.v1"

extension No_Entur_Abt_Core_V1_TokenIdentityStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TOKEN_IDENTITY_STATUS_UNSPECIFIED"),
    1: .same(proto: "TOKEN_IDENTITY_STATUS_OK"),
    2: .same(proto: "TOKEN_IDENTITY_STATUS_NOT_FOUND"),
    3: .same(proto: "TOKEN_IDENTITY_STATUS_INVALID"),
  ]
}

extension No_Entur_Abt_Core_V1_TokenStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TOKEN_STATUS_UNSPECIFIED"),
    1: .same(proto: "TOKEN_STATUS_VALID"),
    2: .same(proto: "TOKEN_STATUS_MARKED_INACTIVE"),
    3: .same(proto: "TOKEN_STATUS_VALIDITY_NOT_STARTED"),
    4: .same(proto: "TOKEN_STATUS_VALIDITY_ENDED"),
    5: .same(proto: "TOKEN_STATUS_NOT_FOUND"),
    6: .same(proto: "TOKEN_STATUS_TYPE_MISMATCH"),
    7: .same(proto: "TOKEN_STATUS_CERTIFICATE_MISMATCH"),
    8: .same(proto: "TOKEN_STATUS_ACTIONS_MISMATCH"),
    9: .same(proto: "TOKEN_STATUS_CLOCK_SKEW"),
    10: .same(proto: "TOKEN_STATUS_SIGNATURE_INVALID"),
    11: .same(proto: "TOKEN_STATUS_CERTIFICATE_INVALID"),
    12: .same(proto: "TOKEN_STATUS_LOCAL_TOKEN_INVALID"),
    13: .same(proto: "TOKEN_STATUS_DEVICE_INFO_MISMATCH"),
    14: .same(proto: "TOKEN_STATUS_ACTIONS_NOT_ALLOWED"),
    15: .same(proto: "TOKEN_STATUS_TYPE_NOT_ALLOWED"),
    16: .same(proto: "TOKEN_STATUS_ENCODING_FORMAT_INVALID"),
  ]
}

extension No_Entur_Abt_Core_V1_TokenIdentification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenIdentification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "multi_customer_account_strategy"),
    1: .standard(proto: "secure_container_token"),
    2: .standard(proto: "token_identifier"),
    3: .standard(proto: "nod_travel_card_identifier"),
    4: .standard(proto: "reference_code_id_token"),
    5: .standard(proto: "local_id_token"),
    7: .standard(proto: "emv_id_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: No_Entur_Abt_Core_V1_SecureContainer?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .secureContainerToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .secureContainerToken(v)
        }
      }()
      case 2: try {
        var v: No_Entur_Abt_Core_V1_TokenIdentifier?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .tokenIdentifier(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .tokenIdentifier(v)
        }
      }()
      case 3: try {
        var v: No_Entur_Abt_Core_V1_NodTravelCardIdentifier?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .nodTravelCardIdentifier(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .nodTravelCardIdentifier(v)
        }
      }()
      case 4: try {
        var v: No_Entur_Abt_Core_V1_ReferenceCodeIdToken?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .referenceCodeIDToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .referenceCodeIDToken(v)
        }
      }()
      case 5: try {
        var v: No_Entur_Abt_Core_V1_LocalIDToken?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .localIDToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .localIDToken(v)
        }
      }()
      case 7: try {
        var v: No_Entur_Abt_Core_V1_EMVIdToken?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .emvIDToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .emvIDToken(v)
        }
      }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._multiCustomerAccountStrategy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .secureContainerToken?: try {
      guard case .secureContainerToken(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .tokenIdentifier?: try {
      guard case .tokenIdentifier(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .nodTravelCardIdentifier?: try {
      guard case .nodTravelCardIdentifier(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .referenceCodeIDToken?: try {
      guard case .referenceCodeIDToken(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .localIDToken?: try {
      guard case .localIDToken(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .emvIDToken?: try {
      guard case .emvIDToken(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try { if let v = self._multiCustomerAccountStrategy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_TokenIdentification, rhs: No_Entur_Abt_Core_V1_TokenIdentification) -> Bool {
    if lhs._multiCustomerAccountStrategy != rhs._multiCustomerAccountStrategy {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_TokenIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_TokenIdentifier, rhs: No_Entur_Abt_Core_V1_TokenIdentifier) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_NodTravelCardIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NodTravelCardIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "travel_card_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.travelCardID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.travelCardID.isEmpty {
      try visitor.visitSingularStringField(value: self.travelCardID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_NodTravelCardIdentifier, rhs: No_Entur_Abt_Core_V1_NodTravelCardIdentifier) -> Bool {
    if lhs.travelCardID != rhs.travelCardID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_ReferenceCodeIdToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReferenceCodeIdToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reference_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.referenceCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.referenceCode.isEmpty {
      try visitor.visitSingularStringField(value: self.referenceCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_ReferenceCodeIdToken, rhs: No_Entur_Abt_Core_V1_ReferenceCodeIdToken) -> Bool {
    if lhs.referenceCode != rhs.referenceCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_LocalIDToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LocalIDToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "token_content"),
    6: .standard(proto: "additional_payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.tokenContent) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.additionalPayload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.tokenContent.isEmpty {
      try visitor.visitSingularBytesField(value: self.tokenContent, fieldNumber: 2)
    }
    if !self.additionalPayload.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.additionalPayload, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_LocalIDToken, rhs: No_Entur_Abt_Core_V1_LocalIDToken) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.tokenContent != rhs.tokenContent {return false}
    if lhs.additionalPayload != rhs.additionalPayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_EMVIdToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EMVIdToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "emv_transit_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.emvTransitToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emvTransitToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.emvTransitToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_EMVIdToken, rhs: No_Entur_Abt_Core_V1_EMVIdToken) -> Bool {
    if lhs.emvTransitToken != rhs.emvTransitToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MultiCustomerAccountStrategy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "single_account_only"),
    2: .standard(proto: "single_account_within_fixed_codespace_only"),
    3: .standard(proto: "multiple_accounts_any_codespace"),
    4: .standard(proto: "multiple_accounts_within_fixed_codespaces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountOnly?
        var hadOneofValue = false
        if let current = self.strategy {
          hadOneofValue = true
          if case .singleAccountOnly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.strategy = .singleAccountOnly(v)
        }
      }()
      case 2: try {
        var v: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountWithinFixedCodespaceOnly?
        var hadOneofValue = false
        if let current = self.strategy {
          hadOneofValue = true
          if case .singleAccountWithinFixedCodespaceOnly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.strategy = .singleAccountWithinFixedCodespaceOnly(v)
        }
      }()
      case 3: try {
        var v: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsAnyCodespace?
        var hadOneofValue = false
        if let current = self.strategy {
          hadOneofValue = true
          if case .multipleAccountsAnyCodespace(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.strategy = .multipleAccountsAnyCodespace(v)
        }
      }()
      case 4: try {
        var v: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsWithinFixedCodespaces?
        var hadOneofValue = false
        if let current = self.strategy {
          hadOneofValue = true
          if case .multipleAccountsWithinFixedCodespaces(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.strategy = .multipleAccountsWithinFixedCodespaces(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.strategy {
    case .singleAccountOnly?: try {
      guard case .singleAccountOnly(let v)? = self.strategy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .singleAccountWithinFixedCodespaceOnly?: try {
      guard case .singleAccountWithinFixedCodespaceOnly(let v)? = self.strategy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .multipleAccountsAnyCodespace?: try {
      guard case .multipleAccountsAnyCodespace(let v)? = self.strategy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .multipleAccountsWithinFixedCodespaces?: try {
      guard case .multipleAccountsWithinFixedCodespaces(let v)? = self.strategy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy, rhs: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy) -> Bool {
    if lhs.strategy != rhs.strategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountOnly: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.protoMessageName + ".SingleAccountOnly"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountOnly, rhs: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountOnly) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountWithinFixedCodespaceOnly: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.protoMessageName + ".SingleAccountWithinFixedCodespaceOnly"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.codespace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.codespace.isEmpty {
      try visitor.visitSingularStringField(value: self.codespace, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountWithinFixedCodespaceOnly, rhs: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.SingleAccountWithinFixedCodespaceOnly) -> Bool {
    if lhs.codespace != rhs.codespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsAnyCodespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.protoMessageName + ".MultipleAccountsAnyCodespace"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsAnyCodespace, rhs: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsAnyCodespace) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsWithinFixedCodespaces: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.protoMessageName + ".MultipleAccountsWithinFixedCodespaces"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codespaces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.codespaces) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.codespaces.isEmpty {
      try visitor.visitRepeatedStringField(value: self.codespaces, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsWithinFixedCodespaces, rhs: No_Entur_Abt_Core_V1_MultiCustomerAccountStrategy.MultipleAccountsWithinFixedCodespaces) -> Bool {
    if lhs.codespaces != rhs.codespaces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_TokenIdentityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenIdentityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "identity"),
    3: .standard(proto: "token_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._identity) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.tokenStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._identity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.tokenStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.tokenStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_TokenIdentityResponse, rhs: No_Entur_Abt_Core_V1_TokenIdentityResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._identity != rhs._identity {return false}
    if lhs.tokenStatus != rhs.tokenStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Core_V1_TokenIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenIdentity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .standard(proto: "token_lifecycle_state"),
    3: .standard(proto: "customer_account_id"),
    4: .standard(proto: "fare_contract_ref"),
    5: .same(proto: "role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.tokenLifecycleState) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.customerAccountID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._fareContractRef) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 1)
    }
    if self.tokenLifecycleState != .unspecified {
      try visitor.visitSingularEnumField(value: self.tokenLifecycleState, fieldNumber: 2)
    }
    if !self.customerAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.customerAccountID, fieldNumber: 3)
    }
    try { if let v = self._fareContractRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.role != .unspecified {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Core_V1_TokenIdentity, rhs: No_Entur_Abt_Core_V1_TokenIdentity) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.tokenLifecycleState != rhs.tokenLifecycleState {return false}
    if lhs.customerAccountID != rhs.customerAccountID {return false}
    if lhs._fareContractRef != rhs._fareContractRef {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
