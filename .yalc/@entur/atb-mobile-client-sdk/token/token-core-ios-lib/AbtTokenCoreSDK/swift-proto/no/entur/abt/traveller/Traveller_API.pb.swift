// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: no/entur/abt/traveller/Traveller_API.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// /home/circleci/project/protobuf-reduced-traveller/target/proto_deps/no/entur/abt/traveller/Traveller_API.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Command to get a list for FareContract for the travellers CustomerAccount.
struct No_Entur_Abt_Traveller_V1_GetFareContractsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  var states: [Uk_Org_Netex_Www_Netex_FareContractLifecycleState] = []

  /// created_from set in the past could make this operation slow. Should not be set as a default value.
  var createdFrom: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdFrom ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdFrom = newValue}
  }
  /// Returns true if `createdFrom` has been explicitly set.
  var hasCreatedFrom: Bool {return self._createdFrom != nil}
  /// Clears the value of `createdFrom`. Subsequent reads from it will return its default value.
  mutating func clearCreatedFrom() {self._createdFrom = nil}

  /// created_to set in the past could make this operation slow. Should not be set as a default value.
  var createdTo: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdTo ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdTo = newValue}
  }
  /// Returns true if `createdTo` has been explicitly set.
  var hasCreatedTo: Bool {return self._createdTo != nil}
  /// Clears the value of `createdTo`. Subsequent reads from it will return its default value.
  mutating func clearCreatedTo() {self._createdTo = nil}

  /// Reference to a specific FareContract. If set only this FareContract will be returned
  var fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _fareContractRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_fareContractRef = newValue}
  }
  /// Returns true if `fareContractRef` has been explicitly set.
  var hasFareContractRef: Bool {return self._fareContractRef != nil}
  /// Clears the value of `fareContractRef`. Subsequent reads from it will return its default value.
  mutating func clearFareContractRef() {self._fareContractRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
  fileprivate var _createdFrom: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _createdTo: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil
}

/// Response for GetFareContractsCommand
struct No_Entur_Abt_Traveller_V1_GetFareContractsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of FareContracts with corresponding visual ticket inspection nonces valid for the FareContracts.
  var fareContracts: [No_Entur_Abt_Traveller_V1_FareContractWithNonces] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A FareContract and list of all the VisualTicketInspectionNonces that are valid for the period(s) when the FareContract is valid in the near future.
struct No_Entur_Abt_Traveller_V1_FareContractWithNonces {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fareContract: Uk_Org_Netex_Www_Netex_FareContractType {
    get {return _fareContract ?? Uk_Org_Netex_Www_Netex_FareContractType()}
    set {_fareContract = newValue}
  }
  /// Returns true if `fareContract` has been explicitly set.
  var hasFareContract: Bool {return self._fareContract != nil}
  /// Clears the value of `fareContract`. Subsequent reads from it will return its default value.
  mutating func clearFareContract() {self._fareContract = nil}

  var nonces: [Uk_Org_Netex_Www_Netex_VisualTicketInspectionNonce] = []

  /// Elements still eligible for consumption for this fare contract
  var consumableElements: [No_Entur_Abt_Core_V1_ConsumableCustomerPurchasePackageElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fareContract: Uk_Org_Netex_Www_Netex_FareContractType? = nil
}

/// Command to report that a Barcode was obtained and presented. Used to correlate actions from the traveller and inspector sides.
struct No_Entur_Abt_Traveller_V1_MobileTokenObtainedNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  /// When the Barcode was obtained
  var when: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _when ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_when = newValue}
  }
  /// Returns true if `when` has been explicitly set.
  var hasWhen: Bool {return self._when != nil}
  /// Clears the value of `when`. Subsequent reads from it will return its default value.
  mutating func clearWhen() {self._when = nil}

  /// True if the visual code has been inverted.
  var visualCodeInverted: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
  fileprivate var _when: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Response for MobileTokenObtainedNotification
struct No_Entur_Abt_Traveller_V1_MobileTokenObtainedNotificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Command to register a new Travelcard as an ID token on the Travellers CustomerAccount. Will not be valid until token data has been written to the physical travelcard, either by PickupTravelCardOrderGroupCommand or by presenting the travelcard to a validator or inspector.
struct No_Entur_Abt_Traveller_V1_RegisterTravelCardCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  /// Identification of the physical Travelcard.
  var travelCardID: String = String()

  /// Unique identification of the new ID token that will be registered for the Travelcard.
  var tokenID: String = String()

  var metadata: No_Entur_Abt_Common_V1_TokenTravelDocumentMetadata {
    get {return _metadata ?? No_Entur_Abt_Common_V1_TokenTravelDocumentMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
  fileprivate var _metadata: No_Entur_Abt_Common_V1_TokenTravelDocumentMetadata? = nil
}

/// Response for RegisterTravelCardCommand
struct No_Entur_Abt_Traveller_V1_RegisterTravelCardResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Command to remove a Travelcard as an ID token on the Travellers CustomerAccount.
struct No_Entur_Abt_Traveller_V1_DeregisterTravelCardCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  /// Unique identification of the travelcard ID token to remove
  var tokenID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
}

/// Response for DeregisterTravelCardCommand
struct No_Entur_Abt_Traveller_V1_DeregisterTravelCardResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Command to get a list of all travelcards on travellers CustomerAccount.
struct No_Entur_Abt_Traveller_V1_GetTravelCardsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
}

/// Response for GetTravelCardsCommand
struct No_Entur_Abt_Traveller_V1_GetTravelCardsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of travelcards
  var travelCards: [No_Entur_Abt_Traveller_V1_TravelCard] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A travelcard registered as an ID token on the travellers CustomerAccount
struct No_Entur_Abt_Traveller_V1_TravelCard {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identification of the physical Travelcard.
  var travelCardID: String = String()

  /// The current lifecycle state of the travelcard ID token.
  var state: Uk_Org_Netex_Www_Netex_TokenLifecycleState = .unspecified

  /// Unique identification of the ID token that is registered for the Travelcard.
  var tokenID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Command to initiate or continue a pickup job to write pending data to a travelcard via NFC. Requires that the client supports NFC and that the traveller has the physical travelcard available. Will result in a number of responses containing apdu commands that must be executed against the card. Return apdu command results by invoking this command again until a final response is returned. Required
struct No_Entur_Abt_Traveller_V1_PickupTravelCardOrderGroupCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  /// Either travelcard identification for new sequences or command results if this is response to an ongoing sequence.
  var content: No_Entur_Abt_Traveller_V1_PickupTravelCardOrderGroupCommand.OneOf_Content? = nil

  /// Results from apdu commands received in previous response
  var commandResults: No_Entur_Abt_Travelcard_V1_ApduResultSet {
    get {
      if case .commandResults(let v)? = content {return v}
      return No_Entur_Abt_Travelcard_V1_ApduResultSet()
    }
    set {content = .commandResults(newValue)}
  }

  /// Identification of the travelcard.
  var travelCardID: String {
    get {
      if case .travelCardID(let v)? = content {return v}
      return String()
    }
    set {content = .travelCardID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Either travelcard identification for new sequences or command results if this is response to an ongoing sequence.
  enum OneOf_Content: Equatable {
    /// Results from apdu commands received in previous response
    case commandResults(No_Entur_Abt_Travelcard_V1_ApduResultSet)
    /// Identification of the travelcard.
    case travelCardID(String)

  #if !swift(>=4.1)
    static func ==(lhs: No_Entur_Abt_Traveller_V1_PickupTravelCardOrderGroupCommand.OneOf_Content, rhs: No_Entur_Abt_Traveller_V1_PickupTravelCardOrderGroupCommand.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.commandResults, .commandResults): return {
        guard case .commandResults(let l) = lhs, case .commandResults(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.travelCardID, .travelCardID): return {
        guard case .travelCardID(let l) = lhs, case .travelCardID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
}

/// Response for PickupTravelCardOrderGroupCommand
struct No_Entur_Abt_Traveller_V1_PickupTravelCardOrderGroupResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status indicating whether sequence has succeeded, failed or is active (ie more APDU commands remains).
  var status: No_Entur_Abt_Travelcard_V1_TravelCardOperationStatus = .unspecified

  /// Apdu commands to execute against card if status indicates operation is ongoing
  var commands: No_Entur_Abt_Travelcard_V1_ApduCommandSet {
    get {return _commands ?? No_Entur_Abt_Travelcard_V1_ApduCommandSet()}
    set {_commands = newValue}
  }
  /// Returns true if `commands` has been explicitly set.
  var hasCommands: Bool {return self._commands != nil}
  /// Clears the value of `commands`. Subsequent reads from it will return its default value.
  mutating func clearCommands() {self._commands = nil}

  /// Messages to client if status is completed.
  var messages: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commands: No_Entur_Abt_Travelcard_V1_ApduCommandSet? = nil
}

/// Command to initiate self inspection of the travellers CustomerAccount. Requires that an advertised ControlChallenge has been received from an inspector and is encoded in MobileIDTokenPayload.
struct No_Entur_Abt_Traveller_V1_SelfInspectCustomerAccountCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
}

/// Response for SelfInspectCustomerAccountCommand
struct No_Entur_Abt_Traveller_V1_SelfInspectCustomerAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Visual ticket inspection code to visualize of travellers device for visual inspection by inspector.
  var visualTicketInspectionCode: Data = Data()

  /// Limitations on result
  var limitationGroup: Uk_Org_Netex_Www_Netex_InspectionResultLimitationGroup {
    get {return _limitationGroup ?? Uk_Org_Netex_Www_Netex_InspectionResultLimitationGroup()}
    set {_limitationGroup = newValue}
  }
  /// Returns true if `limitationGroup` has been explicitly set.
  var hasLimitationGroup: Bool {return self._limitationGroup != nil}
  /// Clears the value of `limitationGroup`. Subsequent reads from it will return its default value.
  mutating func clearLimitationGroup() {self._limitationGroup = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _limitationGroup: Uk_Org_Netex_Www_Netex_InspectionResultLimitationGroup? = nil
}

/// Command to initiate renewal of the travellers Mobile token. Process must be completed by CompleteMobileTokenRenewalCommand.
struct No_Entur_Abt_Traveller_V1_InitiateMobileTokenRenewalCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id for this call
  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  /// The token id for the renewed token. Use a random uuid
  var newTokenID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
}

/// Response for InitiateMobileTokenRenewalCommand
struct No_Entur_Abt_Traveller_V1_InitiateMobileTokenRenewalResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The initialization data required by the mobile device to activate the token
  var initializationData: No_Entur_Abt_Common_V1_MobileTokenInitializationData {
    get {return _initializationData ?? No_Entur_Abt_Common_V1_MobileTokenInitializationData()}
    set {_initializationData = newValue}
  }
  /// Returns true if `initializationData` has been explicitly set.
  var hasInitializationData: Bool {return self._initializationData != nil}
  /// Clears the value of `initializationData`. Subsequent reads from it will return its default value.
  mutating func clearInitializationData() {self._initializationData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _initializationData: No_Entur_Abt_Common_V1_MobileTokenInitializationData? = nil
}

/// Command to complete the renewal of the travellers Mobile token. Requires data from the InitiateMobileTokenRenewalResponse.
struct No_Entur_Abt_Traveller_V1_CompleteMobileTokenRenewalCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id for this call
  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  /// Activation data
  var data: No_Entur_Abt_Traveller_V1_CompleteMobileTokenRenewalCommand.OneOf_Data? = nil

  /// For older clients
  var activationData: No_Entur_Abt_Traveller_V1_MobileTokenActivationData {
    get {
      if case .activationData(let v)? = data {return v}
      return No_Entur_Abt_Traveller_V1_MobileTokenActivationData()
    }
    set {data = .activationData(newValue)}
  }

  /// For updated clients
  var activationDetails: No_Entur_Abt_Traveller_V1_MobileTokenActivationDetails {
    get {
      if case .activationDetails(let v)? = data {return v}
      return No_Entur_Abt_Traveller_V1_MobileTokenActivationDetails()
    }
    set {data = .activationDetails(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Activation data
  enum OneOf_Data: Equatable {
    /// For older clients
    case activationData(No_Entur_Abt_Traveller_V1_MobileTokenActivationData)
    /// For updated clients
    case activationDetails(No_Entur_Abt_Traveller_V1_MobileTokenActivationDetails)

  #if !swift(>=4.1)
    static func ==(lhs: No_Entur_Abt_Traveller_V1_CompleteMobileTokenRenewalCommand.OneOf_Data, rhs: No_Entur_Abt_Traveller_V1_CompleteMobileTokenRenewalCommand.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.activationData, .activationData): return {
        guard case .activationData(let l) = lhs, case .activationData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.activationDetails, .activationDetails): return {
        guard case .activationDetails(let l) = lhs, case .activationDetails(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
}

/// Response for CompleteMobileTokenRenewalCommand
struct No_Entur_Abt_Traveller_V1_CompleteMobileTokenRenewalResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Details about the new token
  var tokenDetails: No_Entur_Abt_Traveller_V1_MobileTokenDetails {
    get {return _tokenDetails ?? No_Entur_Abt_Traveller_V1_MobileTokenDetails()}
    set {_tokenDetails = newValue}
  }
  /// Returns true if `tokenDetails` has been explicitly set.
  var hasTokenDetails: Bool {return self._tokenDetails != nil}
  /// Clears the value of `tokenDetails`. Subsequent reads from it will return its default value.
  mutating func clearTokenDetails() {self._tokenDetails = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tokenDetails: No_Entur_Abt_Traveller_V1_MobileTokenDetails? = nil
}

/// Command to initiate the transfer of a CustomerPurchasePackage from a FareContract on the travellers CustomerAccount to another, unspecified CustomerAccount. Results in a transfer id/url that must be distributed to the client traveller / device receiving the transfer.
struct No_Entur_Abt_Traveller_V1_InitiateTransferCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  /// Reference to the FareContract that contains the CustomerPurchasePackage
  var fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _fareContractRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_fareContractRef = newValue}
  }
  /// Returns true if `fareContractRef` has been explicitly set.
  var hasFareContractRef: Bool {return self._fareContractRef != nil}
  /// Clears the value of `fareContractRef`. Subsequent reads from it will return its default value.
  mutating func clearFareContractRef() {self._fareContractRef = nil}

  /// Reference to the CustomerPurchasePackage to initiate transfer for.
  var customerPurchasePackageRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _customerPurchasePackageRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_customerPurchasePackageRef = newValue}
  }
  /// Returns true if `customerPurchasePackageRef` has been explicitly set.
  var hasCustomerPurchasePackageRef: Bool {return self._customerPurchasePackageRef != nil}
  /// Clears the value of `customerPurchasePackageRef`. Subsequent reads from it will return its default value.
  mutating func clearCustomerPurchasePackageRef() {self._customerPurchasePackageRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
  fileprivate var _fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil
  fileprivate var _customerPurchasePackageRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil
}

/// Response for InitiateTransferCommand
struct No_Entur_Abt_Traveller_V1_InitiateTransferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Id of the initiated transfer
  var transferID: String = String()

  /// Url of initiated transfer
  var transferURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Command to accept the transfer of a CustomerPurchasePackage from a FareContract on another CustomerAccount to the travellers CustomerAccount. Requires a transfer_id obtained from InitiateTransferCommand (for the other traveller) or CustomerPurchasePackageTransferService.InitiateCustomerPurchasePackageTransferCommand
struct No_Entur_Abt_Traveller_V1_AcceptTransferCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  /// Id of the initiated transfer
  var transferID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
}

/// Response for AcceptTransferCommand
struct No_Entur_Abt_Traveller_V1_AcceptTransferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reference to the FareContract to which the CustomerPurchasePackage was added
  var fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _fareContractRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_fareContractRef = newValue}
  }
  /// Returns true if `fareContractRef` has been explicitly set.
  var hasFareContractRef: Bool {return self._fareContractRef != nil}
  /// Clears the value of `fareContractRef`. Subsequent reads from it will return its default value.
  mutating func clearFareContractRef() {self._fareContractRef = nil}

  /// Reference to the CustomerPurchasePackage that was transferred to the travellers CustomerAccount
  var customerPurchasePackageRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _customerPurchasePackageRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_customerPurchasePackageRef = newValue}
  }
  /// Returns true if `customerPurchasePackageRef` has been explicitly set.
  var hasCustomerPurchasePackageRef: Bool {return self._customerPurchasePackageRef != nil}
  /// Clears the value of `customerPurchasePackageRef`. Subsequent reads from it will return its default value.
  mutating func clearCustomerPurchasePackageRef() {self._customerPurchasePackageRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil
  fileprivate var _customerPurchasePackageRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil
}

/// Command to reject the transfer of a CustomerPurchasePackage from a FareContract on another CustomerAccount to the travellers CustomerAccount. Requires a transfer_id obtained from InitiateTransferCommand (for the other traveller) or CustomerPurchasePackageTransferService.InitiateCustomerPurchasePackageTransferCommand. Used if the traveller chooses to decline the transfer.
struct No_Entur_Abt_Traveller_V1_RejectTransferCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  /// Id of the initiated transfer
  var transferID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
}

/// Response for RejectTransferCommand
struct No_Entur_Abt_Traveller_V1_RejectTransferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Command to withdraw the transfer of a CustomerPurchasePackage from a FareContract on another CustomerAccount to the travellers CustomerAccount. Requires a transfer_id obtained from InitiateTransferCommand (for the other traveller) or CustomerPurchasePackageTransferService.InitiateCustomerPurchasePackageTransferCommand. Used if the traveller no longer wants to transfer the CPP (and it has not yet been accepted).
struct No_Entur_Abt_Traveller_V1_WithdrawTransferCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  /// Id of the initiated transfer
  var transferID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
}

/// Command to get details about the contents of a CustomerPurchasePackage that is available for transfer from a FareContract on another CustomerAccount to the travellers CustomerAccount. Requires a transfer_id obtained from InitiateTransferCommand (for the other traveller) or CustomerPurchasePackageTransferService.InitiateCustomerPurchasePackageTransferCommand.
struct No_Entur_Abt_Traveller_V1_GetTransferDetailsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  /// Id of the initiated transfer
  var transferID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
}

/// Response for GetTransferDetailsCommand
struct No_Entur_Abt_Traveller_V1_GetTransferDetailsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fareContract: Uk_Org_Netex_Www_Netex_FareContractType {
    get {return _fareContract ?? Uk_Org_Netex_Www_Netex_FareContractType()}
    set {_fareContract = newValue}
  }
  /// Returns true if `fareContract` has been explicitly set.
  var hasFareContract: Bool {return self._fareContract != nil}
  /// Clears the value of `fareContract`. Subsequent reads from it will return its default value.
  mutating func clearFareContract() {self._fareContract = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fareContract: Uk_Org_Netex_Www_Netex_FareContractType? = nil
}

/// Command to get details about the Mobile token used by this traveller for authentication.
struct No_Entur_Abt_Traveller_V1_GetMobileTokenDetailsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
}

/// Response for GetMobileTokenDetailsCommand
struct No_Entur_Abt_Traveller_V1_GetMobileTokenDetailsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Details about the Mobile token used by this traveller for authentication.
  var tokenDetails: No_Entur_Abt_Traveller_V1_MobileTokenDetails {
    get {return _tokenDetails ?? No_Entur_Abt_Traveller_V1_MobileTokenDetails()}
    set {_tokenDetails = newValue}
  }
  /// Returns true if `tokenDetails` has been explicitly set.
  var hasTokenDetails: Bool {return self._tokenDetails != nil}
  /// Clears the value of `tokenDetails`. Subsequent reads from it will return its default value.
  mutating func clearTokenDetails() {self._tokenDetails = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tokenDetails: No_Entur_Abt_Traveller_V1_MobileTokenDetails? = nil
}

/// Response for WithdrawTransferCommand
struct No_Entur_Abt_Traveller_V1_WithdrawTransferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Command to initialize the transfer of all FareContracts on the travellers CustomerAccount to another, unspecified CustomerAccount. Results in a transfer id/url that must be distributed to the client traveller / device receiving the transfer.
struct No_Entur_Abt_Traveller_V1_InitiateTransferAllFareContractsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
}

/// Response for InitiateTransferAllFareContractsCommand
struct No_Entur_Abt_Traveller_V1_InitiateTransferAllFareContractsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Id of the initiated transfer
  var transferID: String = String()

  /// Url of initiated transfer
  var transferURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Command to accept the transfer of all FareContracts another CustomerAccount to the travellers CustomerAccount. Requires a transfer_id obtained from InitiateTransferAllFareContractsCommand (for the other traveller) or CustomerPurchasePackageTransferService.InitiateTransferAllFareContractsCommand.
struct No_Entur_Abt_Traveller_V1_AcceptTransferAllFareContractsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  /// Id of the initiated transfer
  var transferID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
}

/// Response for AcceptTransferAllFareContractsCommand
struct No_Entur_Abt_Traveller_V1_AcceptTransferAllFareContractsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of references to all the FareContracts transferred to the travellers CustomerAccount.
  var fareContractRef: [Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Command to initialize the transfer of the Mobile token from the travellers CustomerAccount to another, unspecified CustomerAccount. Results in a transfer id/url that must be distributed to the client traveller / device receiving the transfer.
struct No_Entur_Abt_Traveller_V1_InitiateMobileTokenTransferCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
}

/// Response for InitiateMobileTokenTransferCommand
struct No_Entur_Abt_Traveller_V1_InitiateMobileTokenTransferResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Id of the initiated transfer
  var transferID: String = String()

  /// Url of initiated transfer
  var transferURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Command to consume one or more specified CustomerPurchasePackageElements for a given FareContract on the travellers CustomerAccount.
struct No_Entur_Abt_Traveller_V1_ConsumeFareContractCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  /// The fare contract to be consumed
  var fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _fareContractRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_fareContractRef = newValue}
  }
  /// Returns true if `fareContractRef` has been explicitly set.
  var hasFareContractRef: Bool {return self._fareContractRef != nil}
  /// Clears the value of `fareContractRef`. Subsequent reads from it will return its default value.
  mutating func clearFareContractRef() {self._fareContractRef = nil}

  /// Consumption specifications for one or more specified CustomerPurchasePackageElements.
  var elementConsumptionSpecifications: [No_Entur_Abt_Core_V1_CustomerPurchasePackageElementConsumptionSpecification] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
  fileprivate var _fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil
}

/// Response for ConsumeFareContractCommand
struct No_Entur_Abt_Traveller_V1_ConsumeFareContractResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///  Deprecated: Will be removed. Use customer_purchase_package_element_accesses instead.  Elements that were consumed
  var consumedElements: [Uk_Org_Netex_Www_Netex_ConsumedCustomerPurchasePackageElement] = []

  /// References to the customer purchase package element accesses that was created by this consume
  var customerPurchasePackageElementAccesses: [Uk_Org_Netex_Www_Netex_CustomerPurchasePackageElementAccessType] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct No_Entur_Abt_Traveller_V1_RevertConsumeFareContractCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id. Used for idempotency
  var commandID: No_Entur_Abt_Common_V1_CommandId {
    get {return _commandID ?? No_Entur_Abt_Common_V1_CommandId()}
    set {_commandID = newValue}
  }
  /// Returns true if `commandID` has been explicitly set.
  var hasCommandID: Bool {return self._commandID != nil}
  /// Clears the value of `commandID`. Subsequent reads from it will return its default value.
  mutating func clearCommandID() {self._commandID = nil}

  /// Reference to the farecontract that contains the element consumption that should be reverted
  var fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure {
    get {return _fareContractRef ?? Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure()}
    set {_fareContractRef = newValue}
  }
  /// Returns true if `fareContractRef` has been explicitly set.
  var hasFareContractRef: Bool {return self._fareContractRef != nil}
  /// Clears the value of `fareContractRef`. Subsequent reads from it will return its default value.
  mutating func clearFareContractRef() {self._fareContractRef = nil}

  /// Ref to the customer purchase package element access that should be reverted
  var customerPurchasePackageElementAccessRef: [Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commandID: No_Entur_Abt_Common_V1_CommandId? = nil
  fileprivate var _fareContractRef: Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure? = nil
}

struct No_Entur_Abt_Traveller_V1_RevertConsumeFareContractResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The reverted customer purchase package element access
  var customerPurchasePackageElementAccessRef: [Uk_Org_Netex_Www_Netex_VersionOfObjectRefStructure] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension No_Entur_Abt_Traveller_V1_GetFareContractsCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_GetFareContractsResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_FareContractWithNonces: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_MobileTokenObtainedNotification: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_MobileTokenObtainedNotificationResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_RegisterTravelCardCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_RegisterTravelCardResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_DeregisterTravelCardCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_DeregisterTravelCardResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_GetTravelCardsCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_GetTravelCardsResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_TravelCard: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_PickupTravelCardOrderGroupCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_PickupTravelCardOrderGroupCommand.OneOf_Content: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_PickupTravelCardOrderGroupResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_SelfInspectCustomerAccountCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_SelfInspectCustomerAccountResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_InitiateMobileTokenRenewalCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_InitiateMobileTokenRenewalResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_CompleteMobileTokenRenewalCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_CompleteMobileTokenRenewalCommand.OneOf_Data: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_CompleteMobileTokenRenewalResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_InitiateTransferCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_InitiateTransferResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_AcceptTransferCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_AcceptTransferResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_RejectTransferCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_RejectTransferResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_WithdrawTransferCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_GetTransferDetailsCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_GetTransferDetailsResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_GetMobileTokenDetailsCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_GetMobileTokenDetailsResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_WithdrawTransferResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_InitiateTransferAllFareContractsCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_InitiateTransferAllFareContractsResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_AcceptTransferAllFareContractsCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_AcceptTransferAllFareContractsResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_InitiateMobileTokenTransferCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_InitiateMobileTokenTransferResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_ConsumeFareContractCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_ConsumeFareContractResponse: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_RevertConsumeFareContractCommand: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_RevertConsumeFareContractResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "no.entur.abt.traveller.v1"

extension No_Entur_Abt_Traveller_V1_GetFareContractsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetFareContractsCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    2: .same(proto: "states"),
    3: .standard(proto: "created_from"),
    4: .standard(proto: "created_to"),
    5: .standard(proto: "fare_contract_ref"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.states) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdFrom) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createdTo) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._fareContractRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.states.isEmpty {
      try visitor.visitPackedEnumField(value: self.states, fieldNumber: 2)
    }
    try { if let v = self._createdFrom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._createdTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._fareContractRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_GetFareContractsCommand, rhs: No_Entur_Abt_Traveller_V1_GetFareContractsCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.states != rhs.states {return false}
    if lhs._createdFrom != rhs._createdFrom {return false}
    if lhs._createdTo != rhs._createdTo {return false}
    if lhs._fareContractRef != rhs._fareContractRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_GetFareContractsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetFareContractsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fare_contracts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fareContracts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fareContracts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fareContracts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_GetFareContractsResponse, rhs: No_Entur_Abt_Traveller_V1_GetFareContractsResponse) -> Bool {
    if lhs.fareContracts != rhs.fareContracts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_FareContractWithNonces: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FareContractWithNonces"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fare_contract"),
    2: .same(proto: "nonces"),
    3: .standard(proto: "consumable_elements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fareContract) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nonces) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.consumableElements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fareContract {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nonces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nonces, fieldNumber: 2)
    }
    if !self.consumableElements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.consumableElements, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_FareContractWithNonces, rhs: No_Entur_Abt_Traveller_V1_FareContractWithNonces) -> Bool {
    if lhs._fareContract != rhs._fareContract {return false}
    if lhs.nonces != rhs.nonces {return false}
    if lhs.consumableElements != rhs.consumableElements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_MobileTokenObtainedNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MobileTokenObtainedNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    3: .same(proto: "when"),
    5: .standard(proto: "visual_code_inverted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._when) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.visualCodeInverted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._when {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.visualCodeInverted != false {
      try visitor.visitSingularBoolField(value: self.visualCodeInverted, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_MobileTokenObtainedNotification, rhs: No_Entur_Abt_Traveller_V1_MobileTokenObtainedNotification) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs._when != rhs._when {return false}
    if lhs.visualCodeInverted != rhs.visualCodeInverted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_MobileTokenObtainedNotificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MobileTokenObtainedNotificationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_MobileTokenObtainedNotificationResponse, rhs: No_Entur_Abt_Traveller_V1_MobileTokenObtainedNotificationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_RegisterTravelCardCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterTravelCardCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    3: .standard(proto: "travel_card_id"),
    4: .standard(proto: "token_id"),
    5: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.travelCardID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.travelCardID.isEmpty {
      try visitor.visitSingularStringField(value: self.travelCardID, fieldNumber: 3)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 4)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_RegisterTravelCardCommand, rhs: No_Entur_Abt_Traveller_V1_RegisterTravelCardCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.travelCardID != rhs.travelCardID {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_RegisterTravelCardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterTravelCardResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_RegisterTravelCardResponse, rhs: No_Entur_Abt_Traveller_V1_RegisterTravelCardResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_DeregisterTravelCardCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeregisterTravelCardCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    2: .standard(proto: "token_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_DeregisterTravelCardCommand, rhs: No_Entur_Abt_Traveller_V1_DeregisterTravelCardCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_DeregisterTravelCardResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeregisterTravelCardResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_DeregisterTravelCardResponse, rhs: No_Entur_Abt_Traveller_V1_DeregisterTravelCardResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_GetTravelCardsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTravelCardsCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_GetTravelCardsCommand, rhs: No_Entur_Abt_Traveller_V1_GetTravelCardsCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_GetTravelCardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTravelCardsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "travel_cards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.travelCards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.travelCards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.travelCards, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_GetTravelCardsResponse, rhs: No_Entur_Abt_Traveller_V1_GetTravelCardsResponse) -> Bool {
    if lhs.travelCards != rhs.travelCards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_TravelCard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TravelCard"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "travel_card_id"),
    2: .same(proto: "state"),
    4: .standard(proto: "token_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.travelCardID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.travelCardID.isEmpty {
      try visitor.visitSingularStringField(value: self.travelCardID, fieldNumber: 1)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_TravelCard, rhs: No_Entur_Abt_Traveller_V1_TravelCard) -> Bool {
    if lhs.travelCardID != rhs.travelCardID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_PickupTravelCardOrderGroupCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PickupTravelCardOrderGroupCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    101: .standard(proto: "command_results"),
    102: .standard(proto: "travel_card_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 101: try {
        var v: No_Entur_Abt_Travelcard_V1_ApduResultSet?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .commandResults(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .commandResults(v)
        }
      }()
      case 102: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .travelCardID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.content {
    case .commandResults?: try {
      guard case .commandResults(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .travelCardID?: try {
      guard case .travelCardID(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 102)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_PickupTravelCardOrderGroupCommand, rhs: No_Entur_Abt_Traveller_V1_PickupTravelCardOrderGroupCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_PickupTravelCardOrderGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PickupTravelCardOrderGroupResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "commands"),
    3: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._commands) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._commands {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.messages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.messages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_PickupTravelCardOrderGroupResponse, rhs: No_Entur_Abt_Traveller_V1_PickupTravelCardOrderGroupResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._commands != rhs._commands {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_SelfInspectCustomerAccountCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelfInspectCustomerAccountCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_SelfInspectCustomerAccountCommand, rhs: No_Entur_Abt_Traveller_V1_SelfInspectCustomerAccountCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_SelfInspectCustomerAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SelfInspectCustomerAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "visual_ticket_inspection_code"),
    2: .standard(proto: "limitation_group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.visualTicketInspectionCode) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._limitationGroup) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.visualTicketInspectionCode.isEmpty {
      try visitor.visitSingularBytesField(value: self.visualTicketInspectionCode, fieldNumber: 1)
    }
    try { if let v = self._limitationGroup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_SelfInspectCustomerAccountResponse, rhs: No_Entur_Abt_Traveller_V1_SelfInspectCustomerAccountResponse) -> Bool {
    if lhs.visualTicketInspectionCode != rhs.visualTicketInspectionCode {return false}
    if lhs._limitationGroup != rhs._limitationGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_InitiateMobileTokenRenewalCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitiateMobileTokenRenewalCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    3: .standard(proto: "new_token_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.newTokenID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.newTokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.newTokenID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_InitiateMobileTokenRenewalCommand, rhs: No_Entur_Abt_Traveller_V1_InitiateMobileTokenRenewalCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.newTokenID != rhs.newTokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_InitiateMobileTokenRenewalResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitiateMobileTokenRenewalResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "initialization_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._initializationData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._initializationData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_InitiateMobileTokenRenewalResponse, rhs: No_Entur_Abt_Traveller_V1_InitiateMobileTokenRenewalResponse) -> Bool {
    if lhs._initializationData != rhs._initializationData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_CompleteMobileTokenRenewalCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompleteMobileTokenRenewalCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    2: .standard(proto: "activation_data"),
    3: .standard(proto: "activation_details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 2: try {
        var v: No_Entur_Abt_Traveller_V1_MobileTokenActivationData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .activationData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .activationData(v)
        }
      }()
      case 3: try {
        var v: No_Entur_Abt_Traveller_V1_MobileTokenActivationDetails?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .activationDetails(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .activationDetails(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.data {
    case .activationData?: try {
      guard case .activationData(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .activationDetails?: try {
      guard case .activationDetails(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_CompleteMobileTokenRenewalCommand, rhs: No_Entur_Abt_Traveller_V1_CompleteMobileTokenRenewalCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_CompleteMobileTokenRenewalResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompleteMobileTokenRenewalResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenDetails) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_CompleteMobileTokenRenewalResponse, rhs: No_Entur_Abt_Traveller_V1_CompleteMobileTokenRenewalResponse) -> Bool {
    if lhs._tokenDetails != rhs._tokenDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_InitiateTransferCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitiateTransferCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    3: .standard(proto: "fare_contract_ref"),
    4: .standard(proto: "customer_purchase_package_ref"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fareContractRef) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._customerPurchasePackageRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fareContractRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._customerPurchasePackageRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_InitiateTransferCommand, rhs: No_Entur_Abt_Traveller_V1_InitiateTransferCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs._fareContractRef != rhs._fareContractRef {return false}
    if lhs._customerPurchasePackageRef != rhs._customerPurchasePackageRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_InitiateTransferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitiateTransferResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transfer_id"),
    2: .standard(proto: "transfer_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transferID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transferURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transferID.isEmpty {
      try visitor.visitSingularStringField(value: self.transferID, fieldNumber: 1)
    }
    if !self.transferURL.isEmpty {
      try visitor.visitSingularStringField(value: self.transferURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_InitiateTransferResponse, rhs: No_Entur_Abt_Traveller_V1_InitiateTransferResponse) -> Bool {
    if lhs.transferID != rhs.transferID {return false}
    if lhs.transferURL != rhs.transferURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_AcceptTransferCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcceptTransferCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    3: .standard(proto: "transfer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.transferID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transferID.isEmpty {
      try visitor.visitSingularStringField(value: self.transferID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_AcceptTransferCommand, rhs: No_Entur_Abt_Traveller_V1_AcceptTransferCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.transferID != rhs.transferID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_AcceptTransferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcceptTransferResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fare_contract_ref"),
    2: .standard(proto: "customer_purchase_package_ref"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fareContractRef) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._customerPurchasePackageRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fareContractRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._customerPurchasePackageRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_AcceptTransferResponse, rhs: No_Entur_Abt_Traveller_V1_AcceptTransferResponse) -> Bool {
    if lhs._fareContractRef != rhs._fareContractRef {return false}
    if lhs._customerPurchasePackageRef != rhs._customerPurchasePackageRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_RejectTransferCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RejectTransferCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    3: .standard(proto: "transfer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.transferID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transferID.isEmpty {
      try visitor.visitSingularStringField(value: self.transferID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_RejectTransferCommand, rhs: No_Entur_Abt_Traveller_V1_RejectTransferCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.transferID != rhs.transferID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_RejectTransferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RejectTransferResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_RejectTransferResponse, rhs: No_Entur_Abt_Traveller_V1_RejectTransferResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_WithdrawTransferCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WithdrawTransferCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    3: .standard(proto: "transfer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.transferID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transferID.isEmpty {
      try visitor.visitSingularStringField(value: self.transferID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_WithdrawTransferCommand, rhs: No_Entur_Abt_Traveller_V1_WithdrawTransferCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.transferID != rhs.transferID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_GetTransferDetailsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTransferDetailsCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    3: .standard(proto: "transfer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.transferID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transferID.isEmpty {
      try visitor.visitSingularStringField(value: self.transferID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_GetTransferDetailsCommand, rhs: No_Entur_Abt_Traveller_V1_GetTransferDetailsCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.transferID != rhs.transferID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_GetTransferDetailsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTransferDetailsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fare_contract"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fareContract) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fareContract {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_GetTransferDetailsResponse, rhs: No_Entur_Abt_Traveller_V1_GetTransferDetailsResponse) -> Bool {
    if lhs._fareContract != rhs._fareContract {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_GetMobileTokenDetailsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMobileTokenDetailsCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_GetMobileTokenDetailsCommand, rhs: No_Entur_Abt_Traveller_V1_GetMobileTokenDetailsCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_GetMobileTokenDetailsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMobileTokenDetailsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenDetails) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_GetMobileTokenDetailsResponse, rhs: No_Entur_Abt_Traveller_V1_GetMobileTokenDetailsResponse) -> Bool {
    if lhs._tokenDetails != rhs._tokenDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_WithdrawTransferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WithdrawTransferResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_WithdrawTransferResponse, rhs: No_Entur_Abt_Traveller_V1_WithdrawTransferResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_InitiateTransferAllFareContractsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitiateTransferAllFareContractsCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_InitiateTransferAllFareContractsCommand, rhs: No_Entur_Abt_Traveller_V1_InitiateTransferAllFareContractsCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_InitiateTransferAllFareContractsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitiateTransferAllFareContractsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transfer_id"),
    2: .standard(proto: "transfer_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transferID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transferURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transferID.isEmpty {
      try visitor.visitSingularStringField(value: self.transferID, fieldNumber: 1)
    }
    if !self.transferURL.isEmpty {
      try visitor.visitSingularStringField(value: self.transferURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_InitiateTransferAllFareContractsResponse, rhs: No_Entur_Abt_Traveller_V1_InitiateTransferAllFareContractsResponse) -> Bool {
    if lhs.transferID != rhs.transferID {return false}
    if lhs.transferURL != rhs.transferURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_AcceptTransferAllFareContractsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcceptTransferAllFareContractsCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    3: .standard(proto: "transfer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.transferID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transferID.isEmpty {
      try visitor.visitSingularStringField(value: self.transferID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_AcceptTransferAllFareContractsCommand, rhs: No_Entur_Abt_Traveller_V1_AcceptTransferAllFareContractsCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.transferID != rhs.transferID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_AcceptTransferAllFareContractsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcceptTransferAllFareContractsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fare_contract_ref"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fareContractRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fareContractRef.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fareContractRef, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_AcceptTransferAllFareContractsResponse, rhs: No_Entur_Abt_Traveller_V1_AcceptTransferAllFareContractsResponse) -> Bool {
    if lhs.fareContractRef != rhs.fareContractRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_InitiateMobileTokenTransferCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitiateMobileTokenTransferCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_InitiateMobileTokenTransferCommand, rhs: No_Entur_Abt_Traveller_V1_InitiateMobileTokenTransferCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_InitiateMobileTokenTransferResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InitiateMobileTokenTransferResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transfer_id"),
    2: .standard(proto: "transfer_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transferID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transferURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transferID.isEmpty {
      try visitor.visitSingularStringField(value: self.transferID, fieldNumber: 1)
    }
    if !self.transferURL.isEmpty {
      try visitor.visitSingularStringField(value: self.transferURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_InitiateMobileTokenTransferResponse, rhs: No_Entur_Abt_Traveller_V1_InitiateMobileTokenTransferResponse) -> Bool {
    if lhs.transferID != rhs.transferID {return false}
    if lhs.transferURL != rhs.transferURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_ConsumeFareContractCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConsumeFareContractCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    2: .standard(proto: "fare_contract_ref"),
    3: .standard(proto: "element_consumption_specifications"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fareContractRef) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.elementConsumptionSpecifications) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fareContractRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.elementConsumptionSpecifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elementConsumptionSpecifications, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_ConsumeFareContractCommand, rhs: No_Entur_Abt_Traveller_V1_ConsumeFareContractCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs._fareContractRef != rhs._fareContractRef {return false}
    if lhs.elementConsumptionSpecifications != rhs.elementConsumptionSpecifications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_ConsumeFareContractResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConsumeFareContractResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consumed_elements"),
    2: .standard(proto: "customer_purchase_package_element_accesses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.consumedElements) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.customerPurchasePackageElementAccesses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.consumedElements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.consumedElements, fieldNumber: 1)
    }
    if !self.customerPurchasePackageElementAccesses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customerPurchasePackageElementAccesses, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_ConsumeFareContractResponse, rhs: No_Entur_Abt_Traveller_V1_ConsumeFareContractResponse) -> Bool {
    if lhs.consumedElements != rhs.consumedElements {return false}
    if lhs.customerPurchasePackageElementAccesses != rhs.customerPurchasePackageElementAccesses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_RevertConsumeFareContractCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevertConsumeFareContractCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_id"),
    2: .standard(proto: "fare_contract_ref"),
    3: .standard(proto: "customer_purchase_package_element_access_ref"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commandID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fareContractRef) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.customerPurchasePackageElementAccessRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commandID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fareContractRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.customerPurchasePackageElementAccessRef.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customerPurchasePackageElementAccessRef, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_RevertConsumeFareContractCommand, rhs: No_Entur_Abt_Traveller_V1_RevertConsumeFareContractCommand) -> Bool {
    if lhs._commandID != rhs._commandID {return false}
    if lhs._fareContractRef != rhs._fareContractRef {return false}
    if lhs.customerPurchasePackageElementAccessRef != rhs.customerPurchasePackageElementAccessRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_RevertConsumeFareContractResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RevertConsumeFareContractResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "customer_purchase_package_element_access_ref"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.customerPurchasePackageElementAccessRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.customerPurchasePackageElementAccessRef.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customerPurchasePackageElementAccessRef, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_RevertConsumeFareContractResponse, rhs: No_Entur_Abt_Traveller_V1_RevertConsumeFareContractResponse) -> Bool {
    if lhs.customerPurchasePackageElementAccessRef != rhs.customerPurchasePackageElementAccessRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
