// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: no/entur/abt/traveller/Traveller_Messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// /home/circleci/project/protobuf-reduced-traveller/target/proto_deps/no/entur/abt/traveller/Traveller_Messages.proto

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Attestation of a public key
struct No_Entur_Abt_Traveller_V1_KeyAttestation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A chain of certificates of format X.509 certifying that the key is valid and signed by an appropriate authority. Required for android.
  var certificateChain: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Encoding of data used with device attestation
struct No_Entur_Abt_Traveller_V1_DeviceAttestationData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The actual nonce as received from the server
  var nonce: Data = Data()

  /// Device details for the device that produced the attestation
  var deviceInfo: [Uk_Org_Netex_Www_Netex_DeviceInfoElement] = []

  /// The public key used for encryption
  var encryptionPublicKey: Data = Data()

  var signatureKey: No_Entur_Abt_Traveller_V1_DeviceAttestationData.OneOf_SignatureKey? = nil

  /// The public key used for identification. Used for all devices except IOS >= 14.
  var signaturePublicKey: Data {
    get {
      if case .signaturePublicKey(let v)? = signatureKey {return v}
      return Data()
    }
    set {signatureKey = .signaturePublicKey(newValue)}
  }

  /// The keyId used for the signature key pair. Used for IOS >=14 devices where key resides in Secure enclave and is not directly accessible from DcAppAttest API.
  var signatureKeyID: String {
    get {
      if case .signatureKeyID(let v)? = signatureKey {return v}
      return String()
    }
    set {signatureKey = .signatureKeyID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SignatureKey: Equatable {
    /// The public key used for identification. Used for all devices except IOS >= 14.
    case signaturePublicKey(Data)
    /// The keyId used for the signature key pair. Used for IOS >=14 devices where key resides in Secure enclave and is not directly accessible from DcAppAttest API.
    case signatureKeyID(String)

  #if !swift(>=4.1)
    static func ==(lhs: No_Entur_Abt_Traveller_V1_DeviceAttestationData.OneOf_SignatureKey, rhs: No_Entur_Abt_Traveller_V1_DeviceAttestationData.OneOf_SignatureKey) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.signaturePublicKey, .signaturePublicKey): return {
        guard case .signaturePublicKey(let l) = lhs, case .signaturePublicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.signatureKeyID, .signatureKeyID): return {
        guard case .signatureKeyID(let l) = lhs, case .signatureKeyID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Device attestation for Google SafetyNet for Android devices.
struct No_Entur_Abt_Traveller_V1_AndroidSafetyNetAttestation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// JWS encoded result from Google SafetyNet
  var jwsResult: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Message containing encrypted result from IOS DeviceCheck. Used in serialized and encrypted form in IOSDeviceCheckAttestation.encrypted_ios_device_check_data
struct No_Entur_Abt_Traveller_V1_EncryptedIOSDeviceCheckData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Attestation data from device. DeviceInfo types APPLICATION_ID and APPLICATION_VERSION is required.
  var deviceAttestationData: No_Entur_Abt_Traveller_V1_DeviceAttestationData {
    get {return _deviceAttestationData ?? No_Entur_Abt_Traveller_V1_DeviceAttestationData()}
    set {_deviceAttestationData = newValue}
  }
  /// Returns true if `deviceAttestationData` has been explicitly set.
  var hasDeviceAttestationData: Bool {return self._deviceAttestationData != nil}
  /// Clears the value of `deviceAttestationData`. Subsequent reads from it will return its default value.
  mutating func clearDeviceAttestationData() {self._deviceAttestationData = nil}

  /// Token for ABT system to use against IOS DeviceCheck API to verify attestation data
  var deviceCheckToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deviceAttestationData: No_Entur_Abt_Traveller_V1_DeviceAttestationData? = nil
}

/// Attestation data for IOS DeviceCheck. See https://developer.apple.com/documentation/devicecheck.
struct No_Entur_Abt_Traveller_V1_IOSDeviceCheckAttestation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// JWT to be used to authorize request to apple DeviceCheck API to verify attestation. Added by the PTA backend. Must make sure JWT is created with necessary access rights.
  var appleJwtToken: String = String()

  /// DEPRECATED: specify encrypted_device_check instead. The encrypted attestation data. Format (for non encrypted data) is defined by EncryptedIOSDeviceCheckData. Create and populate an EncryptedIOSDeviceCheckData and used binary serialization of it as payload for encryption.
  var encryptedIosDeviceCheckData: Data = Data()

  /// DEPRECATED: specify encrypted_device_check instead. Use RSA encrypted AES key. Encrypted with the attestation_encryption_public_key. AES key should be created on the device with length: 128 bits, padding: PKCS5Padding,mode: Cipher Block Chaining. Specified IV parameter for encryption should be 16 bytes with all 0 values.
  var attestationEncryptionEncryptedKey: Data = Data()

  /// The result of the device check.
  var deviceCheckResult: No_Entur_Abt_Traveller_V1_IOSDeviceCheckResult {
    get {return _deviceCheckResult ?? No_Entur_Abt_Traveller_V1_IOSDeviceCheckResult()}
    set {_deviceCheckResult = newValue}
  }
  /// Returns true if `deviceCheckResult` has been explicitly set.
  var hasDeviceCheckResult: Bool {return self._deviceCheckResult != nil}
  /// Clears the value of `deviceCheckResult`. Subsequent reads from it will return its default value.
  mutating func clearDeviceCheckResult() {self._deviceCheckResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deviceCheckResult: No_Entur_Abt_Traveller_V1_IOSDeviceCheckResult? = nil
}

/// Encrypted IOS Device Check data with encrypted AES key for decryption of device check data.
struct No_Entur_Abt_Traveller_V1_IOSDeviceCheckResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The encrypted attestation data. Format (for non encrypted data) is defined by EncryptedIOSDeviceCheckData. Create and populate an EncryptedIOSDeviceCheckData and used binary serialization of it as payload for encryption.
  var encryptedIosDeviceCheckData: Data = Data()

  /// RSA encrypted AES key. Encrypted with the attestation_encryption_public_key. AES key should be created on the device with length: 128 bits, padding: PKCS5Padding,mode: Cipher Block Chaining. Specified IV parameter for encryption should be 16 bytes with all 0 values.
  var attestationEncryptionEncryptedKey: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DEPRECATED - Use IOSAppAttestAssertion for reattestation instead. Attestation data for IOS Device attestation.
struct No_Entur_Abt_Traveller_V1_IOSDeviceAttestation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// B64 encoded, generated on client. Should be created with a binary serialized DeviceAttestationData as a challenge.
  var attestationObject: String = String()

  /// B64 encoded key id, from generated ios app attest data on the client side.
  var keyID: String = String()

  /// Binary serialized DeviceAttestationData. DeviceInfo types APPLICATION_ID and APPLICATION_VERSION is required. Deprecated. Now sent via DeviceCheck data
  var deviceAttestationData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Attestation data for IOS Device check AppAttest assertion. See https://developer.apple.com/documentation/devicecheck/dcappattestservice/3573912-generateassertion.
struct No_Entur_Abt_Traveller_V1_IOSAppAttestAssertion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Binary serialized IOSDeviceCheckResult. DeviceInfo types APPLICATION_ID, APPLICATION_VERSION, APPLE_TEAM_IDENTIFIER and OS_API_LEVEL is required.
  var deviceCheckResult: Data = Data()

  /// B64 encoded, generated on client. Should be created with the device_check_attestation byte array as a challenge.
  var assertionObject: String = String()

  /// JWT to be used to authorize request to apple DeviceCheck API to verify attestation. Added by the PTA backend. Must make sure JWT is created with necessary access rights.
  var appleJwtToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Attestation data for IOS Device check AppAttest attestation. See https://developer.apple.com/documentation/devicecheck/dcappattestservice/3573911-attestkey.
struct No_Entur_Abt_Traveller_V1_IOSAppAttestAttestation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Binary serialized IOSDeviceCheckResult. DeviceInfo types APPLICATION_ID, APPLICATION_VERSION, APPLE_TEAM_IDENTIFIER and OS_API_LEVEL is required.
  var deviceCheckResult: Data = Data()

  /// B64 encoded, generated on client. Should be created with the serialized device_check_attestation byte array as a challenge.
  var attestationObject: String = String()

  /// JWT to be used to authorize request to apple DeviceCheck API to verify attestation AND DcAppAttest API to verify receipt. Added by the PTA backend. Must make sure JWT is created with necessary access rights.
  var appleJwtToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Attestation data for NonceOnly attestation - Should only be used for test
struct No_Entur_Abt_Traveller_V1_NonceOnlyAttestation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common device attestation data
  var deviceAttestationData: No_Entur_Abt_Traveller_V1_DeviceAttestationData {
    get {return _deviceAttestationData ?? No_Entur_Abt_Traveller_V1_DeviceAttestationData()}
    set {_deviceAttestationData = newValue}
  }
  /// Returns true if `deviceAttestationData` has been explicitly set.
  var hasDeviceAttestationData: Bool {return self._deviceAttestationData != nil}
  /// Clears the value of `deviceAttestationData`. Subsequent reads from it will return its default value.
  mutating func clearDeviceAttestationData() {self._deviceAttestationData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deviceAttestationData: No_Entur_Abt_Traveller_V1_DeviceAttestationData? = nil
}

/// Common device attestation wrapper for types of device attestation
struct No_Entur_Abt_Traveller_V1_Attestation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of attestation performed
  var type: Uk_Org_Netex_Www_Netex_AttestationType = .unspecified

  var attestationContent: No_Entur_Abt_Traveller_V1_Attestation.OneOf_AttestationContent? = nil

  /// Result of android safetynet attestation
  var androidSafetynet: No_Entur_Abt_Traveller_V1_AndroidSafetyNetAttestation {
    get {
      if case .androidSafetynet(let v)? = attestationContent {return v}
      return No_Entur_Abt_Traveller_V1_AndroidSafetyNetAttestation()
    }
    set {attestationContent = .androidSafetynet(newValue)}
  }

  /// Result of ios device check attestation - iOS version < 14 only.
  var iosDeviceCheck: No_Entur_Abt_Traveller_V1_IOSDeviceCheckAttestation {
    get {
      if case .iosDeviceCheck(let v)? = attestationContent {return v}
      return No_Entur_Abt_Traveller_V1_IOSDeviceCheckAttestation()
    }
    set {attestationContent = .iosDeviceCheck(newValue)}
  }

  /// DEPRECATED: Use IOSAppAttestAssertion for reattestation instead. Use Result of ios device attestation
  var iosDeviceAttest: No_Entur_Abt_Traveller_V1_IOSDeviceAttestation {
    get {
      if case .iosDeviceAttest(let v)? = attestationContent {return v}
      return No_Entur_Abt_Traveller_V1_IOSDeviceAttestation()
    }
    set {attestationContent = .iosDeviceAttest(newValue)}
  }

  /// Result of nonce only attestation
  var nonceOnly: No_Entur_Abt_Traveller_V1_NonceOnlyAttestation {
    get {
      if case .nonceOnly(let v)? = attestationContent {return v}
      return No_Entur_Abt_Traveller_V1_NonceOnlyAttestation()
    }
    set {attestationContent = .nonceOnly(newValue)}
  }

  /// Result of ios device check AppAttest assertion. For iOS version >= 14.
  var iosAppAttestAssertion: No_Entur_Abt_Traveller_V1_IOSAppAttestAssertion {
    get {
      if case .iosAppAttestAssertion(let v)? = attestationContent {return v}
      return No_Entur_Abt_Traveller_V1_IOSAppAttestAssertion()
    }
    set {attestationContent = .iosAppAttestAssertion(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_AttestationContent: Equatable {
    /// Result of android safetynet attestation
    case androidSafetynet(No_Entur_Abt_Traveller_V1_AndroidSafetyNetAttestation)
    /// Result of ios device check attestation - iOS version < 14 only.
    case iosDeviceCheck(No_Entur_Abt_Traveller_V1_IOSDeviceCheckAttestation)
    /// DEPRECATED: Use IOSAppAttestAssertion for reattestation instead. Use Result of ios device attestation
    case iosDeviceAttest(No_Entur_Abt_Traveller_V1_IOSDeviceAttestation)
    /// Result of nonce only attestation
    case nonceOnly(No_Entur_Abt_Traveller_V1_NonceOnlyAttestation)
    /// Result of ios device check AppAttest assertion. For iOS version >= 14.
    case iosAppAttestAssertion(No_Entur_Abt_Traveller_V1_IOSAppAttestAssertion)

  #if !swift(>=4.1)
    static func ==(lhs: No_Entur_Abt_Traveller_V1_Attestation.OneOf_AttestationContent, rhs: No_Entur_Abt_Traveller_V1_Attestation.OneOf_AttestationContent) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.androidSafetynet, .androidSafetynet): return {
        guard case .androidSafetynet(let l) = lhs, case .androidSafetynet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iosDeviceCheck, .iosDeviceCheck): return {
        guard case .iosDeviceCheck(let l) = lhs, case .iosDeviceCheck(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iosDeviceAttest, .iosDeviceAttest): return {
        guard case .iosDeviceAttest(let l) = lhs, case .iosDeviceAttest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nonceOnly, .nonceOnly): return {
        guard case .nonceOnly(let l) = lhs, case .nonceOnly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iosAppAttestAssertion, .iosAppAttestAssertion): return {
        guard case .iosAppAttestAssertion(let l) = lhs, case .iosAppAttestAssertion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Details for the travellers Mobile token
struct No_Entur_Abt_Traveller_V1_MobileTokenDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique command id for this call
  /// The uuid of the token
  var tokenID: String = String()

  /// A certificate of format X.509 certifying that the token public key is valid
  var signatureCertificate: Data = Data()

  /// Token start date
  var tokenValidityStart: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _tokenValidityStart ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_tokenValidityStart = newValue}
  }
  /// Returns true if `tokenValidityStart` has been explicitly set.
  var hasTokenValidityStart: Bool {return self._tokenValidityStart != nil}
  /// Clears the value of `tokenValidityStart`. Subsequent reads from it will return its default value.
  mutating func clearTokenValidityStart() {self._tokenValidityStart = nil}

  /// Certificate end date
  var tokenValidityEnd: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _tokenValidityEnd ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_tokenValidityEnd = newValue}
  }
  /// Returns true if `tokenValidityEnd` has been explicitly set.
  var hasTokenValidityEnd: Bool {return self._tokenValidityEnd != nil}
  /// Clears the value of `tokenValidityEnd`. Subsequent reads from it will return its default value.
  mutating func clearTokenValidityEnd() {self._tokenValidityEnd = nil}

  /// List of TokenActions allowed for this token
  var allowedActions: [Uk_Org_Netex_Www_Netex_TokenAction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tokenValidityStart: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _tokenValidityEnd: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// DEPRECATED: Use MobileTokenActivationDetails instead. Use Activation data for activating a Mobile token in a secure manner.
struct No_Entur_Abt_Traveller_V1_MobileTokenActivationData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The uuid of the token
  var tokenID: String = String()

  /// The result of the SafetyNet or DeviceCheck device attestation
  var deviceAttestation: No_Entur_Abt_Traveller_V1_Attestation {
    get {return _deviceAttestation ?? No_Entur_Abt_Traveller_V1_Attestation()}
    set {_deviceAttestation = newValue}
  }
  /// Returns true if `deviceAttestation` has been explicitly set.
  var hasDeviceAttestation: Bool {return self._deviceAttestation != nil}
  /// Clears the value of `deviceAttestation`. Subsequent reads from it will return its default value.
  mutating func clearDeviceAttestation() {self._deviceAttestation = nil}

  /// The public key of the token key pair. Encoded as X.509. The key pair must be generated using EC algorithm. See other documentation for exact requirements.
  var signaturePublicKey: Data = Data()

  /// The public key of the "encryption" key pair. Encoded as X.509. The key pair must be generated using RSA algorithm. See other documentation for exact requirements.
  var encryptionPublicKey: Data = Data()

  /// Attestation for public key to be used for identification of token. Required for android.
  var signaturePublicKeyAttestation: No_Entur_Abt_Traveller_V1_KeyAttestation {
    get {return _signaturePublicKeyAttestation ?? No_Entur_Abt_Traveller_V1_KeyAttestation()}
    set {_signaturePublicKeyAttestation = newValue}
  }
  /// Returns true if `signaturePublicKeyAttestation` has been explicitly set.
  var hasSignaturePublicKeyAttestation: Bool {return self._signaturePublicKeyAttestation != nil}
  /// Clears the value of `signaturePublicKeyAttestation`. Subsequent reads from it will return its default value.
  mutating func clearSignaturePublicKeyAttestation() {self._signaturePublicKeyAttestation = nil}

  /// Attestation for public key to be used for encryption of data to client. Required for android.
  var encryptionPublicKeyAttestation: No_Entur_Abt_Traveller_V1_KeyAttestation {
    get {return _encryptionPublicKeyAttestation ?? No_Entur_Abt_Traveller_V1_KeyAttestation()}
    set {_encryptionPublicKeyAttestation = newValue}
  }
  /// Returns true if `encryptionPublicKeyAttestation` has been explicitly set.
  var hasEncryptionPublicKeyAttestation: Bool {return self._encryptionPublicKeyAttestation != nil}
  /// Clears the value of `encryptionPublicKeyAttestation`. Subsequent reads from it will return its default value.
  mutating func clearEncryptionPublicKeyAttestation() {self._encryptionPublicKeyAttestation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _deviceAttestation: No_Entur_Abt_Traveller_V1_Attestation? = nil
  fileprivate var _signaturePublicKeyAttestation: No_Entur_Abt_Traveller_V1_KeyAttestation? = nil
  fileprivate var _encryptionPublicKeyAttestation: No_Entur_Abt_Traveller_V1_KeyAttestation? = nil
}

/// Activation data for activating a Mobile token in a secure manner.
struct No_Entur_Abt_Traveller_V1_MobileTokenActivationDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The uuid of the token
  var tokenID: String = String()

  /// Device specific activation data.
  var activationData: No_Entur_Abt_Traveller_V1_MobileTokenActivationDetails.OneOf_ActivationData? = nil

  /// Android specific activation details.
  var android: No_Entur_Abt_Traveller_V1_AndroidMobileTokenActivationDetails {
    get {
      if case .android(let v)? = activationData {return v}
      return No_Entur_Abt_Traveller_V1_AndroidMobileTokenActivationDetails()
    }
    set {activationData = .android(newValue)}
  }

  /// IOS specific activation details.
  var ios: No_Entur_Abt_Traveller_V1_IOSMobileTokenActivationDetails {
    get {
      if case .ios(let v)? = activationData {return v}
      return No_Entur_Abt_Traveller_V1_IOSMobileTokenActivationDetails()
    }
    set {activationData = .ios(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Device specific activation data.
  enum OneOf_ActivationData: Equatable {
    /// Android specific activation details.
    case android(No_Entur_Abt_Traveller_V1_AndroidMobileTokenActivationDetails)
    /// IOS specific activation details.
    case ios(No_Entur_Abt_Traveller_V1_IOSMobileTokenActivationDetails)

  #if !swift(>=4.1)
    static func ==(lhs: No_Entur_Abt_Traveller_V1_MobileTokenActivationDetails.OneOf_ActivationData, rhs: No_Entur_Abt_Traveller_V1_MobileTokenActivationDetails.OneOf_ActivationData) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.android, .android): return {
        guard case .android(let l) = lhs, case .android(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ios, .ios): return {
        guard case .ios(let l) = lhs, case .ios(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Activation data for activating an Android Mobile token in a secure manner.
struct No_Entur_Abt_Traveller_V1_AndroidMobileTokenActivationDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Attestation for public key to be used for identification of token. Required for devices with hardware and OS api level that supports key attestation.
  var signaturePublicKeyAttestation: No_Entur_Abt_Traveller_V1_KeyAttestation {
    get {return _signaturePublicKeyAttestation ?? No_Entur_Abt_Traveller_V1_KeyAttestation()}
    set {_signaturePublicKeyAttestation = newValue}
  }
  /// Returns true if `signaturePublicKeyAttestation` has been explicitly set.
  var hasSignaturePublicKeyAttestation: Bool {return self._signaturePublicKeyAttestation != nil}
  /// Clears the value of `signaturePublicKeyAttestation`. Subsequent reads from it will return its default value.
  mutating func clearSignaturePublicKeyAttestation() {self._signaturePublicKeyAttestation = nil}

  /// Attestation for public key to be used for encryption of data to client. Required for devices with hardware and OS api level that supports key attestation.
  var encryptionPublicKeyAttestation: No_Entur_Abt_Traveller_V1_KeyAttestation {
    get {return _encryptionPublicKeyAttestation ?? No_Entur_Abt_Traveller_V1_KeyAttestation()}
    set {_encryptionPublicKeyAttestation = newValue}
  }
  /// Returns true if `encryptionPublicKeyAttestation` has been explicitly set.
  var hasEncryptionPublicKeyAttestation: Bool {return self._encryptionPublicKeyAttestation != nil}
  /// Clears the value of `encryptionPublicKeyAttestation`. Subsequent reads from it will return its default value.
  mutating func clearEncryptionPublicKeyAttestation() {self._encryptionPublicKeyAttestation = nil}

  /// Attestation type specific details
  var deviceAttestation: No_Entur_Abt_Traveller_V1_AndroidMobileTokenActivationDetails.OneOf_DeviceAttestation? = nil

  /// Safetynet attestation
  var safetynet: No_Entur_Abt_Traveller_V1_AndroidSafetyNetAttestation {
    get {
      if case .safetynet(let v)? = deviceAttestation {return v}
      return No_Entur_Abt_Traveller_V1_AndroidSafetyNetAttestation()
    }
    set {deviceAttestation = .safetynet(newValue)}
  }

  /// Nonce only attestation - not allowed in production.
  var nonceOnly: No_Entur_Abt_Traveller_V1_NonceOnlyAttestation {
    get {
      if case .nonceOnly(let v)? = deviceAttestation {return v}
      return No_Entur_Abt_Traveller_V1_NonceOnlyAttestation()
    }
    set {deviceAttestation = .nonceOnly(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Attestation type specific details
  enum OneOf_DeviceAttestation: Equatable {
    /// Safetynet attestation
    case safetynet(No_Entur_Abt_Traveller_V1_AndroidSafetyNetAttestation)
    /// Nonce only attestation - not allowed in production.
    case nonceOnly(No_Entur_Abt_Traveller_V1_NonceOnlyAttestation)

  #if !swift(>=4.1)
    static func ==(lhs: No_Entur_Abt_Traveller_V1_AndroidMobileTokenActivationDetails.OneOf_DeviceAttestation, rhs: No_Entur_Abt_Traveller_V1_AndroidMobileTokenActivationDetails.OneOf_DeviceAttestation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.safetynet, .safetynet): return {
        guard case .safetynet(let l) = lhs, case .safetynet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nonceOnly, .nonceOnly): return {
        guard case .nonceOnly(let l) = lhs, case .nonceOnly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _signaturePublicKeyAttestation: No_Entur_Abt_Traveller_V1_KeyAttestation? = nil
  fileprivate var _encryptionPublicKeyAttestation: No_Entur_Abt_Traveller_V1_KeyAttestation? = nil
}

/// Activation data for activating an IOS Mobile token in a secure manner.
struct No_Entur_Abt_Traveller_V1_IOSMobileTokenActivationDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Attestation type specific details
  var attestation: No_Entur_Abt_Traveller_V1_IOSMobileTokenActivationDetails.OneOf_Attestation? = nil

  /// Device check attestation. Only used for iOS version < 14.
  var deviceCheck: No_Entur_Abt_Traveller_V1_IOSDeviceCheckAttestation {
    get {
      if case .deviceCheck(let v)? = attestation {return v}
      return No_Entur_Abt_Traveller_V1_IOSDeviceCheckAttestation()
    }
    set {attestation = .deviceCheck(newValue)}
  }

  /// DcAppAttest attestation. Used for iOS version >= 14.
  var appAttestAttestation: No_Entur_Abt_Traveller_V1_IOSAppAttestAttestation {
    get {
      if case .appAttestAttestation(let v)? = attestation {return v}
      return No_Entur_Abt_Traveller_V1_IOSAppAttestAttestation()
    }
    set {attestation = .appAttestAttestation(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Attestation type specific details
  enum OneOf_Attestation: Equatable {
    /// Device check attestation. Only used for iOS version < 14.
    case deviceCheck(No_Entur_Abt_Traveller_V1_IOSDeviceCheckAttestation)
    /// DcAppAttest attestation. Used for iOS version >= 14.
    case appAttestAttestation(No_Entur_Abt_Traveller_V1_IOSAppAttestAttestation)

  #if !swift(>=4.1)
    static func ==(lhs: No_Entur_Abt_Traveller_V1_IOSMobileTokenActivationDetails.OneOf_Attestation, rhs: No_Entur_Abt_Traveller_V1_IOSMobileTokenActivationDetails.OneOf_Attestation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.deviceCheck, .deviceCheck): return {
        guard case .deviceCheck(let l) = lhs, case .deviceCheck(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appAttestAttestation, .appAttestAttestation): return {
        guard case .appAttestAttestation(let l) = lhs, case .appAttestAttestation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension No_Entur_Abt_Traveller_V1_KeyAttestation: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_DeviceAttestationData: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_DeviceAttestationData.OneOf_SignatureKey: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_AndroidSafetyNetAttestation: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_EncryptedIOSDeviceCheckData: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_IOSDeviceCheckAttestation: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_IOSDeviceCheckResult: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_IOSDeviceAttestation: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_IOSAppAttestAssertion: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_IOSAppAttestAttestation: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_NonceOnlyAttestation: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_Attestation: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_Attestation.OneOf_AttestationContent: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_MobileTokenDetails: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_MobileTokenActivationData: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_MobileTokenActivationDetails: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_MobileTokenActivationDetails.OneOf_ActivationData: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_AndroidMobileTokenActivationDetails: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_AndroidMobileTokenActivationDetails.OneOf_DeviceAttestation: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_IOSMobileTokenActivationDetails: @unchecked Sendable {}
extension No_Entur_Abt_Traveller_V1_IOSMobileTokenActivationDetails.OneOf_Attestation: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "no.entur.abt.traveller.v1"

extension No_Entur_Abt_Traveller_V1_KeyAttestation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyAttestation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "certificate_chain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.certificateChain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.certificateChain.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.certificateChain, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_KeyAttestation, rhs: No_Entur_Abt_Traveller_V1_KeyAttestation) -> Bool {
    if lhs.certificateChain != rhs.certificateChain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_DeviceAttestationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceAttestationData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    3: .same(proto: "deviceInfo"),
    4: .standard(proto: "encryption_public_key"),
    2: .standard(proto: "signature_public_key"),
    5: .standard(proto: "signature_key_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.signatureKey != nil {try decoder.handleConflictingOneOf()}
          self.signatureKey = .signaturePublicKey(v)
        }
      }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.deviceInfo) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.encryptionPublicKey) }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.signatureKey != nil {try decoder.handleConflictingOneOf()}
          self.signatureKey = .signatureKeyID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 1)
    }
    try { if case .signaturePublicKey(let v)? = self.signatureKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    if !self.deviceInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deviceInfo, fieldNumber: 3)
    }
    if !self.encryptionPublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptionPublicKey, fieldNumber: 4)
    }
    try { if case .signatureKeyID(let v)? = self.signatureKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_DeviceAttestationData, rhs: No_Entur_Abt_Traveller_V1_DeviceAttestationData) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.deviceInfo != rhs.deviceInfo {return false}
    if lhs.encryptionPublicKey != rhs.encryptionPublicKey {return false}
    if lhs.signatureKey != rhs.signatureKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_AndroidSafetyNetAttestation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AndroidSafetyNetAttestation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "jws_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jwsResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jwsResult.isEmpty {
      try visitor.visitSingularStringField(value: self.jwsResult, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_AndroidSafetyNetAttestation, rhs: No_Entur_Abt_Traveller_V1_AndroidSafetyNetAttestation) -> Bool {
    if lhs.jwsResult != rhs.jwsResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_EncryptedIOSDeviceCheckData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptedIOSDeviceCheckData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_attestation_data"),
    2: .standard(proto: "device_check_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deviceAttestationData) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceCheckToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deviceAttestationData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.deviceCheckToken.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceCheckToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_EncryptedIOSDeviceCheckData, rhs: No_Entur_Abt_Traveller_V1_EncryptedIOSDeviceCheckData) -> Bool {
    if lhs._deviceAttestationData != rhs._deviceAttestationData {return false}
    if lhs.deviceCheckToken != rhs.deviceCheckToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_IOSDeviceCheckAttestation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IOSDeviceCheckAttestation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "apple_jwt_token"),
    1: .standard(proto: "encrypted_ios_device_check_data"),
    3: .standard(proto: "attestation_encryption_encrypted_key"),
    4: .standard(proto: "device_check_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encryptedIosDeviceCheckData) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appleJwtToken) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.attestationEncryptionEncryptedKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._deviceCheckResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.encryptedIosDeviceCheckData.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedIosDeviceCheckData, fieldNumber: 1)
    }
    if !self.appleJwtToken.isEmpty {
      try visitor.visitSingularStringField(value: self.appleJwtToken, fieldNumber: 2)
    }
    if !self.attestationEncryptionEncryptedKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.attestationEncryptionEncryptedKey, fieldNumber: 3)
    }
    try { if let v = self._deviceCheckResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_IOSDeviceCheckAttestation, rhs: No_Entur_Abt_Traveller_V1_IOSDeviceCheckAttestation) -> Bool {
    if lhs.appleJwtToken != rhs.appleJwtToken {return false}
    if lhs.encryptedIosDeviceCheckData != rhs.encryptedIosDeviceCheckData {return false}
    if lhs.attestationEncryptionEncryptedKey != rhs.attestationEncryptionEncryptedKey {return false}
    if lhs._deviceCheckResult != rhs._deviceCheckResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_IOSDeviceCheckResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IOSDeviceCheckResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encrypted_ios_device_check_data"),
    2: .standard(proto: "attestation_encryption_encrypted_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encryptedIosDeviceCheckData) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.attestationEncryptionEncryptedKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encryptedIosDeviceCheckData.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedIosDeviceCheckData, fieldNumber: 1)
    }
    if !self.attestationEncryptionEncryptedKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.attestationEncryptionEncryptedKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_IOSDeviceCheckResult, rhs: No_Entur_Abt_Traveller_V1_IOSDeviceCheckResult) -> Bool {
    if lhs.encryptedIosDeviceCheckData != rhs.encryptedIosDeviceCheckData {return false}
    if lhs.attestationEncryptionEncryptedKey != rhs.attestationEncryptionEncryptedKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_IOSDeviceAttestation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IOSDeviceAttestation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "attestation_object"),
    3: .standard(proto: "key_id"),
    4: .standard(proto: "device_attestation_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.attestationObject) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.deviceAttestationData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attestationObject.isEmpty {
      try visitor.visitSingularStringField(value: self.attestationObject, fieldNumber: 2)
    }
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 3)
    }
    if !self.deviceAttestationData.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceAttestationData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_IOSDeviceAttestation, rhs: No_Entur_Abt_Traveller_V1_IOSDeviceAttestation) -> Bool {
    if lhs.attestationObject != rhs.attestationObject {return false}
    if lhs.keyID != rhs.keyID {return false}
    if lhs.deviceAttestationData != rhs.deviceAttestationData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_IOSAppAttestAssertion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IOSAppAttestAssertion"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_check_result"),
    2: .standard(proto: "assertion_object"),
    3: .standard(proto: "apple_jwt_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.deviceCheckResult) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.assertionObject) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.appleJwtToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceCheckResult.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceCheckResult, fieldNumber: 1)
    }
    if !self.assertionObject.isEmpty {
      try visitor.visitSingularStringField(value: self.assertionObject, fieldNumber: 2)
    }
    if !self.appleJwtToken.isEmpty {
      try visitor.visitSingularStringField(value: self.appleJwtToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_IOSAppAttestAssertion, rhs: No_Entur_Abt_Traveller_V1_IOSAppAttestAssertion) -> Bool {
    if lhs.deviceCheckResult != rhs.deviceCheckResult {return false}
    if lhs.assertionObject != rhs.assertionObject {return false}
    if lhs.appleJwtToken != rhs.appleJwtToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_IOSAppAttestAttestation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IOSAppAttestAttestation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_check_result"),
    2: .standard(proto: "attestation_object"),
    3: .standard(proto: "apple_jwt_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.deviceCheckResult) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.attestationObject) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.appleJwtToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceCheckResult.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceCheckResult, fieldNumber: 1)
    }
    if !self.attestationObject.isEmpty {
      try visitor.visitSingularStringField(value: self.attestationObject, fieldNumber: 2)
    }
    if !self.appleJwtToken.isEmpty {
      try visitor.visitSingularStringField(value: self.appleJwtToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_IOSAppAttestAttestation, rhs: No_Entur_Abt_Traveller_V1_IOSAppAttestAttestation) -> Bool {
    if lhs.deviceCheckResult != rhs.deviceCheckResult {return false}
    if lhs.attestationObject != rhs.attestationObject {return false}
    if lhs.appleJwtToken != rhs.appleJwtToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_NonceOnlyAttestation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NonceOnlyAttestation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_attestation_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deviceAttestationData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deviceAttestationData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_NonceOnlyAttestation, rhs: No_Entur_Abt_Traveller_V1_NonceOnlyAttestation) -> Bool {
    if lhs._deviceAttestationData != rhs._deviceAttestationData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_Attestation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Attestation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    3: .standard(proto: "android_safetynet"),
    4: .standard(proto: "ios_device_check"),
    5: .standard(proto: "ios_device_attest"),
    6: .standard(proto: "nonce_only"),
    7: .standard(proto: "ios_app_attest_assertion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try {
        var v: No_Entur_Abt_Traveller_V1_AndroidSafetyNetAttestation?
        var hadOneofValue = false
        if let current = self.attestationContent {
          hadOneofValue = true
          if case .androidSafetynet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attestationContent = .androidSafetynet(v)
        }
      }()
      case 4: try {
        var v: No_Entur_Abt_Traveller_V1_IOSDeviceCheckAttestation?
        var hadOneofValue = false
        if let current = self.attestationContent {
          hadOneofValue = true
          if case .iosDeviceCheck(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attestationContent = .iosDeviceCheck(v)
        }
      }()
      case 5: try {
        var v: No_Entur_Abt_Traveller_V1_IOSDeviceAttestation?
        var hadOneofValue = false
        if let current = self.attestationContent {
          hadOneofValue = true
          if case .iosDeviceAttest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attestationContent = .iosDeviceAttest(v)
        }
      }()
      case 6: try {
        var v: No_Entur_Abt_Traveller_V1_NonceOnlyAttestation?
        var hadOneofValue = false
        if let current = self.attestationContent {
          hadOneofValue = true
          if case .nonceOnly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attestationContent = .nonceOnly(v)
        }
      }()
      case 7: try {
        var v: No_Entur_Abt_Traveller_V1_IOSAppAttestAssertion?
        var hadOneofValue = false
        if let current = self.attestationContent {
          hadOneofValue = true
          if case .iosAppAttestAssertion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attestationContent = .iosAppAttestAssertion(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.attestationContent {
    case .androidSafetynet?: try {
      guard case .androidSafetynet(let v)? = self.attestationContent else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .iosDeviceCheck?: try {
      guard case .iosDeviceCheck(let v)? = self.attestationContent else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .iosDeviceAttest?: try {
      guard case .iosDeviceAttest(let v)? = self.attestationContent else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .nonceOnly?: try {
      guard case .nonceOnly(let v)? = self.attestationContent else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .iosAppAttestAssertion?: try {
      guard case .iosAppAttestAssertion(let v)? = self.attestationContent else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_Attestation, rhs: No_Entur_Abt_Traveller_V1_Attestation) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.attestationContent != rhs.attestationContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_MobileTokenDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MobileTokenDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .standard(proto: "signature_certificate"),
    3: .standard(proto: "token_validity_start"),
    4: .standard(proto: "token_validity_end"),
    5: .standard(proto: "allowed_actions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signatureCertificate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tokenValidityStart) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tokenValidityEnd) }()
      case 5: try { try decoder.decodeRepeatedEnumField(value: &self.allowedActions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 1)
    }
    if !self.signatureCertificate.isEmpty {
      try visitor.visitSingularBytesField(value: self.signatureCertificate, fieldNumber: 2)
    }
    try { if let v = self._tokenValidityStart {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._tokenValidityEnd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.allowedActions.isEmpty {
      try visitor.visitPackedEnumField(value: self.allowedActions, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_MobileTokenDetails, rhs: No_Entur_Abt_Traveller_V1_MobileTokenDetails) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.signatureCertificate != rhs.signatureCertificate {return false}
    if lhs._tokenValidityStart != rhs._tokenValidityStart {return false}
    if lhs._tokenValidityEnd != rhs._tokenValidityEnd {return false}
    if lhs.allowedActions != rhs.allowedActions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_MobileTokenActivationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MobileTokenActivationData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .standard(proto: "device_attestation"),
    3: .standard(proto: "signature_public_key"),
    4: .standard(proto: "encryption_public_key"),
    5: .standard(proto: "signature_public_key_attestation"),
    6: .standard(proto: "encryption_public_key_attestation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deviceAttestation) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.signaturePublicKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.encryptionPublicKey) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._signaturePublicKeyAttestation) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._encryptionPublicKeyAttestation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 1)
    }
    try { if let v = self._deviceAttestation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signaturePublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.signaturePublicKey, fieldNumber: 3)
    }
    if !self.encryptionPublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptionPublicKey, fieldNumber: 4)
    }
    try { if let v = self._signaturePublicKeyAttestation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._encryptionPublicKeyAttestation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_MobileTokenActivationData, rhs: No_Entur_Abt_Traveller_V1_MobileTokenActivationData) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs._deviceAttestation != rhs._deviceAttestation {return false}
    if lhs.signaturePublicKey != rhs.signaturePublicKey {return false}
    if lhs.encryptionPublicKey != rhs.encryptionPublicKey {return false}
    if lhs._signaturePublicKeyAttestation != rhs._signaturePublicKeyAttestation {return false}
    if lhs._encryptionPublicKeyAttestation != rhs._encryptionPublicKeyAttestation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_MobileTokenActivationDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MobileTokenActivationDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_id"),
    2: .same(proto: "android"),
    3: .same(proto: "ios"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenID) }()
      case 2: try {
        var v: No_Entur_Abt_Traveller_V1_AndroidMobileTokenActivationDetails?
        var hadOneofValue = false
        if let current = self.activationData {
          hadOneofValue = true
          if case .android(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.activationData = .android(v)
        }
      }()
      case 3: try {
        var v: No_Entur_Abt_Traveller_V1_IOSMobileTokenActivationDetails?
        var hadOneofValue = false
        if let current = self.activationData {
          hadOneofValue = true
          if case .ios(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.activationData = .ios(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 1)
    }
    switch self.activationData {
    case .android?: try {
      guard case .android(let v)? = self.activationData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .ios?: try {
      guard case .ios(let v)? = self.activationData else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_MobileTokenActivationDetails, rhs: No_Entur_Abt_Traveller_V1_MobileTokenActivationDetails) -> Bool {
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.activationData != rhs.activationData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_AndroidMobileTokenActivationDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AndroidMobileTokenActivationDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "signature_public_key_attestation"),
    6: .standard(proto: "encryption_public_key_attestation"),
    1: .same(proto: "safetynet"),
    2: .standard(proto: "nonce_only"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: No_Entur_Abt_Traveller_V1_AndroidSafetyNetAttestation?
        var hadOneofValue = false
        if let current = self.deviceAttestation {
          hadOneofValue = true
          if case .safetynet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.deviceAttestation = .safetynet(v)
        }
      }()
      case 2: try {
        var v: No_Entur_Abt_Traveller_V1_NonceOnlyAttestation?
        var hadOneofValue = false
        if let current = self.deviceAttestation {
          hadOneofValue = true
          if case .nonceOnly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.deviceAttestation = .nonceOnly(v)
        }
      }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._signaturePublicKeyAttestation) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._encryptionPublicKeyAttestation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.deviceAttestation {
    case .safetynet?: try {
      guard case .safetynet(let v)? = self.deviceAttestation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .nonceOnly?: try {
      guard case .nonceOnly(let v)? = self.deviceAttestation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._signaturePublicKeyAttestation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._encryptionPublicKeyAttestation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_AndroidMobileTokenActivationDetails, rhs: No_Entur_Abt_Traveller_V1_AndroidMobileTokenActivationDetails) -> Bool {
    if lhs._signaturePublicKeyAttestation != rhs._signaturePublicKeyAttestation {return false}
    if lhs._encryptionPublicKeyAttestation != rhs._encryptionPublicKeyAttestation {return false}
    if lhs.deviceAttestation != rhs.deviceAttestation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension No_Entur_Abt_Traveller_V1_IOSMobileTokenActivationDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IOSMobileTokenActivationDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_check"),
    2: .standard(proto: "app_attest_attestation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: No_Entur_Abt_Traveller_V1_IOSDeviceCheckAttestation?
        var hadOneofValue = false
        if let current = self.attestation {
          hadOneofValue = true
          if case .deviceCheck(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attestation = .deviceCheck(v)
        }
      }()
      case 2: try {
        var v: No_Entur_Abt_Traveller_V1_IOSAppAttestAttestation?
        var hadOneofValue = false
        if let current = self.attestation {
          hadOneofValue = true
          if case .appAttestAttestation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attestation = .appAttestAttestation(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.attestation {
    case .deviceCheck?: try {
      guard case .deviceCheck(let v)? = self.attestation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .appAttestAttestation?: try {
      guard case .appAttestAttestation(let v)? = self.attestation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: No_Entur_Abt_Traveller_V1_IOSMobileTokenActivationDetails, rhs: No_Entur_Abt_Traveller_V1_IOSMobileTokenActivationDetails) -> Bool {
    if lhs.attestation != rhs.attestation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
