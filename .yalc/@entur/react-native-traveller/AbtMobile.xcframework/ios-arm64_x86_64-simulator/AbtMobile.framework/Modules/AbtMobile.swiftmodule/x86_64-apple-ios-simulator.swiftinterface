// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5 (swiftlang-1300.0.31.1 clang-1300.0.29.1)
// swift-module-flags: -target x86_64-apple-ios14.5-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name AbtMobile
import AVFoundation
@_exported import AbtMobile
import CoreBluetooth
import DeviceCheck
import Foundation
import Security
import Swift
import UIKit
import _Concurrency
public struct LegacyAttestation {
  public let attestation: Swift.String
  public let signaturePublicKey: Swift.String
  public let encryptionPublicKey: Swift.String
  public let attestationEncryptionKey: Swift.String
}
@available(iOS 11.0, *)
public class LegacyAttestator {
  public init(tokenId: Swift.String, nonce: Swift.String)
  public func attest(serverPublicKey: Swift.String, deviceDetails: AbtMobile.DeviceDetails, completionHandler: @escaping (Swift.Result<AbtMobile.LegacyAttestation, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public enum LegacyAttestationError : Swift.Error {
  case notSupportedDevice
  public static func == (a: AbtMobile.LegacyAttestationError, b: AbtMobile.LegacyAttestationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AbtMobile.LegacyAttestationError {
  public var description: Swift.String {
    get
  }
}
public struct Token : Swift.Codable {
  public let tokenId: Swift.String
  public let validityStart: Swift.Double
  public let validityEnd: Swift.Double
  public init(tokenId: Swift.String, validityStart: Swift.Double, validityEnd: Swift.Double)
  public var publicKeys: AbtMobile.TokenKeys? {
    get
  }
  public var privateKeys: AbtMobile.TokenKeys? {
    get
  }
  public var certificate: Security.SecCertificate? {
    get
  }
  public func storeCertificate(certificateBase64Encoded: Swift.String, completionHandler: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func storeCertificate(certificate: Security.SecCertificate, completionHandler: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public func clearKeyStore()
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public enum TokenError : Swift.Error {
  case failedToSignTokenUse
  case noStoredCertificate
  case noStoredSignatureKey
  public static func == (a: AbtMobile.TokenError, b: AbtMobile.TokenError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum PayloadAction : Swift.Int {
  case unspecified
  case ticketTransfer
  case addRemoveToken
  case identification
  case ticketInspection
  case getFarecontracts
  case travelcard
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol Message {
  var data: Foundation.Data { get }
  var base64String: Swift.String { get }
  init(data: Foundation.Data)
  init(base64Encoded base64String: Swift.String) throws
}
extension AbtMobile.Message {
  public var base64String: Swift.String {
    get
  }
  public init(base64Encoded base64String: Swift.String) throws
}
@objc @_inheritsConvenienceInitializers public class CryptoExportImportManager : ObjectiveC.NSObject {
  public func exportPublicKeyToDER(_ rawPublicKeyBytes: Foundation.Data, keyType: Swift.String, keySize: Swift.Int) -> Foundation.Data?
  public func exportPublicKeyToPEM(_ rawPublicKeyBytes: Foundation.Data, keyType: Swift.String, keySize: Swift.Int) -> Swift.String?
  public func exportRSAPublicKeyToDER(_ rawPublicKeyBytes: Foundation.Data, keyType: Swift.String, keySize: Swift.Int) -> Foundation.Data
  public func exportRSAPublicKeyToPEM(_ rawPublicKeyBytes: Foundation.Data, keyType: Swift.String, keySize: Swift.Int) -> Swift.String
  public func exportECPublicKeyToDER(_ rawPublicKeyBytes: Foundation.Data, keyType: Swift.String, keySize: Swift.Int) -> Foundation.Data
  public func exportECPublicKeyToPEM(_ rawPublicKeyBytes: Foundation.Data, keyType: Swift.String, keySize: Swift.Int) -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
public class EncryptedMessage : AbtMobile.Message {
  final public let data: Foundation.Data
  required public init(data: Foundation.Data)
  public func decrypted(with key: AbtMobile.PrivateKey, padding: AbtMobile.Padding) throws -> AbtMobile.ClearMessage
  @objc deinit
}
public struct Attestation {
  public let attestationObject: Swift.String
  public let keyId: Swift.String
  public let deviceAttestationData: Swift.String
  public let signaturePublicKey: Swift.String
  public let encryptionPublicKey: Swift.String
}
public enum AttestError : Swift.Error {
  case noPublicKey
  case noEncryptionKey
  case noChallenge
  case noKeyIdentifier
  case noSignatureKey
  case noResultFromKeyAttest
  case couldNotSerializeAttestation
  case failedToGenerateAesKey
  case failedToEncryptData
  case failedToEncryptAesKey
  public static func == (a: AbtMobile.AttestError, b: AbtMobile.AttestError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(iOS 14.0, *)
public class Attestator {
  public init(tokenId: Swift.String, nonce: Swift.String)
  @available(iOS 14.0, *)
  public func attest(deviceDetails: AbtMobile.DeviceDetails, completionHandler: @escaping (Swift.Result<AbtMobile.Attestation, Swift.Error>) -> Swift.Void)
  public func generateAssertion(keyId: Swift.String, hash: Foundation.Data, completionHandler: @escaping (Swift.Result<Swift.String, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public class Signature {
  public enum DigestType {
    case sha1
    case sha224
    case sha256
    case sha384
    case sha512
    public static func == (a: AbtMobile.Signature.DigestType, b: AbtMobile.Signature.DigestType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let data: Foundation.Data
  public init(data: Foundation.Data)
  convenience public init(base64Encoded base64String: Swift.String) throws
  public var base64String: Swift.String {
    get
  }
  @objc deinit
}
public struct TokenKeys {
  public let signatureKey: Security.SecKey
  public let encryptionKey: Security.SecKey
}
public struct KeyStore {
  public init(tag: Swift.String)
  public var privateTokenKeys: AbtMobile.TokenKeys? {
    mutating get
  }
  public func clearKeyStoreForTag()
  public var publicTokenKeys: AbtMobile.TokenKeys? {
    mutating get
  }
  public func storeCertificate(certificate: Security.SecCertificate, completionHandler: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void)
  public var certificate: Security.SecCertificate? {
    get
  }
}
extension Security.SecKey {
  public func toBase64String() -> Swift.String?
  public func toData() -> Foundation.NSData?
  public func publicKeyToPEM() -> Swift.String?
  public func publicKeyToDER() -> Foundation.Data?
}
public enum KeyStoreError : Swift.Error {
  case somethingWentWrong
  case couldNotGetCertificate
  public static func == (a: AbtMobile.KeyStoreError, b: AbtMobile.KeyStoreError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AbtMobile.KeyStoreError {
  public var description: Swift.String {
    get
  }
}
public struct Support {
  public init()
  public var isDCAppAttestServiceAvailable: Swift.Bool {
    get
  }
  public var isDCDeviceAvailable: Swift.Bool {
    get
  }
}
public typealias Padding = Security.SecPadding
public enum SwiftyRSA {
  @available(iOS 10.0, watchOS 3.0, tvOS 10.0, *)
  public static func generateRSAKeyPair(sizeInBits size: Swift.Int) throws -> (privateKey: AbtMobile.PrivateKey, publicKey: AbtMobile.PublicKey)
}
public protocol Key : AnyObject {
  var reference: Security.SecKey { get }
  var originalData: Foundation.Data? { get }
  init(data: Foundation.Data) throws
  init(reference: Security.SecKey) throws
  init(base64Encoded base64String: Swift.String) throws
  init(pemEncoded pemString: Swift.String) throws
  init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle) throws
  init(derNamed derName: Swift.String, in bundle: Foundation.Bundle) throws
  func pemString() throws -> Swift.String
  func data() throws -> Foundation.Data
  func base64String() throws -> Swift.String
}
extension AbtMobile.Key {
  public func base64String() throws -> Swift.String
  public func data() throws -> Foundation.Data
  public init(base64Encoded base64String: Swift.String) throws
  public init(pemEncoded pemString: Swift.String) throws
  public init(pemNamed pemName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
  public init(derNamed derName: Swift.String, in bundle: Foundation.Bundle = Bundle.main) throws
}
public struct TokenStore {
  public init()
  public func deleteActiveToken()
  public func loadActiveToken() -> AbtMobile.Token?
  public func saveActiveToken(token: AbtMobile.Token) -> Swift.Bool
}
public class PublicKey : AbtMobile.Key {
  final public let reference: Security.SecKey
  final public let originalData: Foundation.Data?
  public func pemString() throws -> Swift.String
  required public init(reference: Security.SecKey) throws
  required public init(data: Foundation.Data) throws
  public static func publicKeys(pemEncoded pemString: Swift.String) -> [AbtMobile.PublicKey]
  @objc deinit
}
public class ClearMessage : AbtMobile.Message {
  final public let data: Foundation.Data
  required public init(data: Foundation.Data)
  convenience public init(string: Swift.String, using encoding: Swift.String.Encoding) throws
  public func string(encoding: Swift.String.Encoding) throws -> Swift.String
  public func encrypted(with key: AbtMobile.PublicKey, padding: AbtMobile.Padding) throws -> AbtMobile.EncryptedMessage
  @objc deinit
}
extension Swift.StringProtocol {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.String {
  public var stripPEM: Swift.String {
    get
  }
}
public struct DeviceDetails {
  public let applicationVersion: Swift.String
  public let applicationId: Swift.String
  public init(applicationVersion: Swift.String, applicationId: Swift.String)
}
public enum SwiftyRSAError : Swift.Error {
  case pemDoesNotContainKey
  case keyRepresentationFailed(error: CoreFoundation.CFError?)
  case keyGenerationFailed(error: CoreFoundation.CFError?)
  case keyCreateFailed(error: CoreFoundation.CFError?)
  case keyAddFailed(status: Darwin.OSStatus)
  case keyCopyFailed(status: Darwin.OSStatus)
  case tagEncodingFailed
  case asn1ParsingFailed
  case invalidAsn1RootNode
  case invalidAsn1Structure
  case invalidBase64String
  case chunkDecryptFailed(index: Swift.Int)
  case chunkEncryptFailed(index: Swift.Int)
  case stringToDataConversionFailed
  case dataToStringConversionFailed
  case invalidDigestSize(digestSize: Swift.Int, maxChunkSize: Swift.Int)
  case signatureCreateFailed(status: Darwin.OSStatus)
  case signatureVerifyFailed(status: Darwin.OSStatus)
  case pemFileNotFound(name: Swift.String)
  case derFileNotFound(name: Swift.String)
  case notAPublicKey
  case notAPrivateKey
}
public class PrivateKey : AbtMobile.Key {
  final public let reference: Security.SecKey
  final public let originalData: Foundation.Data?
  public func pemString() throws -> Swift.String
  required public init(reference: Security.SecKey) throws
  required public init(data: Foundation.Data) throws
  @objc deinit
}
public class SecureTokenService {
  public init(deviceDetails: AbtMobile.DeviceDetails)
  @objc deinit
  public func getSecureToken(actions: [AbtMobile.PayloadAction]) -> Swift.Result<Swift.String, AbtMobile.QRCodeServiceError>
}
public enum QRCodeServiceError : Swift.Error {
  case noActiveToken
  case noUpdatedTimestamp
  case tokenEncodingError(tokenError: AbtMobile.TokenError)
  case couldNotSerializeToken
}
@_hasMissingDesignatedInitializers public class DeviceStatus {
  @objc deinit
}
extension AbtMobile.LegacyAttestationError : Swift.Equatable {}
extension AbtMobile.LegacyAttestationError : Swift.Hashable {}
extension AbtMobile.TokenError : Swift.Equatable {}
extension AbtMobile.TokenError : Swift.Hashable {}
extension AbtMobile.PayloadAction : Swift.Equatable {}
extension AbtMobile.PayloadAction : Swift.Hashable {}
extension AbtMobile.PayloadAction : Swift.RawRepresentable {}
extension AbtMobile.AttestError : Swift.Equatable {}
extension AbtMobile.AttestError : Swift.Hashable {}
extension AbtMobile.Signature.DigestType : Swift.Equatable {}
extension AbtMobile.Signature.DigestType : Swift.Hashable {}
extension AbtMobile.KeyStoreError : Swift.Equatable {}
extension AbtMobile.KeyStoreError : Swift.Hashable {}
