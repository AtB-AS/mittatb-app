{"version":3,"sources":["fetcher.ts"],"names":["RequestError","Error","constructor","response","message","status","captureStackTrace","name","ReattestationError","data","reattestationData","createInternalFetcher","config","request","fetch","headers","extraHeaders","isErrorResponse","body","code","metadata","isOk","createFetcher","reattest","fetcher","handleRequest","allowRetry","error","tokenId","nonce","attestationEncryptionPublicKey","reattestBody","jsonBody","JSON","stringify","utf8value","utf8","encode","headerValue","base64","logger","undefined","req"],"mappings":"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","sourcesContent":["import type { ApiRequest, ApiResponse, Config, Fetch } from './config';\nimport type { ActivateTokenRequest } from './token/types';\nimport base64 from 'base-64';\nimport utf8 from 'utf8';\nimport { logger } from './logger';\n\nexport class RequestError extends Error {\n  response: ApiResponse;\n\n  constructor(response: ApiResponse) {\n    const message = `${response.status}`; //: ${response.statusText}`;\n    super(message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, RequestError);\n    }\n\n    this.name = 'RequestError';\n    this.response = response;\n  }\n}\n\ntype ErrorResponse = {\n  code: string;\n  message: string;\n  metadata: any;\n};\n\ntype ReattestationData = {\n  errorReason: 'REATTESTATION_REQUIRED';\n  tokenId: string;\n  nonce: string;\n  attestationEncryptionPublicKey: string;\n};\n\nexport class ReattestationError extends Error {\n  reattestationData: ReattestationData;\n\n  constructor(data: ReattestationData) {\n    const name = 'ReattestationError';\n    super(name);\n\n    this.name = name;\n    this.reattestationData = data;\n  }\n}\n\nfunction createInternalFetcher(config: Config): Fetch {\n  return async <T>(request: ApiRequest) => {\n    const response = await config.fetch<T>({\n      ...request,\n      headers: {\n        ...config?.extraHeaders,\n        ...request?.headers,\n      },\n    });\n\n    if (isErrorResponse(response)) {\n      if (response.body.code === 'REATTESTATION_REQUIRED') {\n        throw new ReattestationError(\n          response.body.metadata as ReattestationData\n        );\n      }\n    }\n\n    if (!isOk(response)) {\n      throw new RequestError(response);\n    }\n\n    return response;\n  };\n}\n\ntype ReattestFunction = (\n  tokenId: string,\n  nonce: string,\n  attestationEncryptionPublicKey: string\n) => Promise<ActivateTokenRequest>;\n\nexport function createFetcher(\n  config: Config,\n  reattest: ReattestFunction\n): Fetch {\n  const fetcher = createInternalFetcher(config);\n\n  const handleRequest = async <T>(\n    request: ApiRequest,\n    allowRetry = true\n  ): Promise<ApiResponse<T>> => {\n    try {\n      return await fetcher<T>(request);\n    } catch (error: any) {\n      if (error instanceof ReattestationError) {\n        const {\n          tokenId,\n          nonce,\n          attestationEncryptionPublicKey,\n        } = error.reattestationData;\n        const reattestBody = await reattest(\n          tokenId,\n          nonce,\n          attestationEncryptionPublicKey\n        );\n\n        const jsonBody = JSON.stringify(reattestBody);\n        const utf8value = utf8.encode(jsonBody);\n        const headerValue = base64.encode(utf8value);\n\n        const headers: Record<string, string> = request.headers ?? {};\n\n        headers['X-Attestation-Data'] = headerValue;\n\n        request.headers = headers;\n\n        return handleRequest(request, true);\n      }\n\n      logger.error(undefined, error, undefined);\n\n      if (error instanceof RequestError) {\n        if (allowRetry) {\n          return handleRequest(request, false);\n        }\n      }\n      throw error;\n    }\n  };\n\n  return (req: ApiRequest) => handleRequest(req, true);\n}\n\nfunction isOk(response: ApiResponse) {\n  return response.status > 199 && response.status < 300;\n}\n\nfunction isErrorResponse(\n  response: ApiResponse\n): response is ApiResponse<ErrorResponse> {\n  return 'code' in response.body;\n}\n"]}