{"version":3,"sources":["fetcher.ts"],"names":["RequestError","Error","constructor","response","message","status","captureStackTrace","name","tokenNeedsRenewal","contentType","headers","isApiErrorBody","body","errorCode","createInternalFetcher","config","request","fetch","extraHeaders","isOk","createFetcher","fetcher","renewTokenLock","renewToken","hosts","handleTokenRenewal","handle","token","finally","undefined","handleRequest","allowRetry","error","req"],"mappings":"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","sourcesContent":["import type {\n  Fetch,\n  Config,\n  ApiResponse,\n  ApiRequest,\n  ApiErrorBody,\n} from './config';\nimport { getToken } from './native';\nimport { createRenewToken } from './token';\n\nexport class RequestError extends Error {\n  response: ApiResponse;\n\n  constructor(response: ApiResponse) {\n    const message = `${response.status}`; //: ${response.statusText}`;\n    super(message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, RequestError);\n    }\n\n    this.name = 'RequestError';\n    this.response = response;\n  }\n}\n\nasync function tokenNeedsRenewal<T>(\n  response: ApiResponse<T>\n): Promise<boolean> {\n  if (response.status !== 401) return false;\n  const contentType = response.headers['content-type'];\n  if (contentType !== 'application/json') return false;\n\n  if (isApiErrorBody(response.body)) {\n    const { errorCode } = await response.body;\n\n    return errorCode === 'TOKEN_EXPIRED';\n  }\n\n  return false;\n}\n\nfunction createInternalFetcher(config: Config): Fetch {\n  return async <T>(request: ApiRequest) => {\n    const response = await config.fetch<T>({\n      ...request,\n      headers: {\n        ...config?.extraHeaders,\n        ...request?.headers,\n      },\n    });\n\n    if (!isOk(response)) {\n      throw new RequestError(response);\n    }\n\n    return response;\n  };\n}\n\nexport function createFetcher(config: Config): Fetch {\n  const fetcher = createInternalFetcher(config);\n\n  let renewTokenLock: Promise<void> | undefined;\n  const renewToken = createRenewToken(fetcher, config.hosts);\n\n  const handleTokenRenewal = () => {\n    const handle = async () => {\n      const token = await getToken();\n      if (!token) return;\n      await renewToken(token);\n    };\n\n    renewTokenLock = handle().finally(() => {\n      renewTokenLock = undefined;\n    });\n\n    return renewTokenLock;\n  };\n\n  const handleRequest = async <T>(\n    request: ApiRequest,\n    allowRetry = true\n  ): Promise<ApiResponse<T>> => {\n    if (renewTokenLock) {\n      await renewTokenLock;\n      return handleRequest(request, false);\n    }\n\n    try {\n      return await fetcher<T>(request);\n    } catch (error) {\n      if (error instanceof RequestError) {\n        const { response } = error;\n        if (allowRetry && (await tokenNeedsRenewal(response))) {\n          await handleTokenRenewal();\n          return handleRequest(request, false);\n        }\n      }\n\n      throw error;\n    }\n  };\n\n  return (req: ApiRequest) => handleRequest(req, true);\n}\n\nfunction isOk(response: ApiResponse) {\n  return response.status > 199 && response.status < 300;\n}\n\nfunction isApiErrorBody(body: any): body is ApiErrorBody {\n  return 'error_code' in body;\n}\n"]}