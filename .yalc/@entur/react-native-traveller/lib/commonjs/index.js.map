{"version":3,"sources":["index.ts"],"names":["INITIAL_RETRY_INTERVAL","MAXIMUM_RETRY_INTERVAL","createClient","setStatus","initialConfig","safetyNetApiKey","currentStatus","currentAccountId","infoLogger","errorLogger","reattest","tokenId","nonce","error","Error","logger","undefined","config","fetcher","abtTokensService","hosts","toVisualState","storedState","missingNetConnection","state","currentRetryInterval","scheduledRetry","scheduleRetry","setTimeout","setStatusWrapper","Math","min","unscheduleRetry","clearTimeout","accountId","status","sanitizeError","visualState","setAccount","retry","forceRestart","toggleToken","Promise","reject","tokens","overrideExisting","listTokens","getSecureToken","actions","resolve","token","newErr","err","message","name","stack"],"mappings":"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","sourcesContent":["import { getConfigFromInitialConfig, InitialConfig } from './config';\nimport { startTokenStateMachine } from './token';\nimport { createFetcher } from './fetcher';\nimport { createAbtTokensService } from './token/abt-tokens-service';\nimport type {\n  Attestation,\n  StoredState,\n  StoredToken,\n  TokenError,\n  TokenStatus,\n  VisualState,\n} from './token/types';\nimport { getSecureToken, getToken } from './native';\nimport type { PayloadAction } from './native/types';\nimport { setupLogger, logger } from './logger';\nimport { getReattestation } from './token/attest';\n\nexport type { StoredToken } from './token/types';\nexport type { Token } from './native/types';\nexport { RequestError } from './fetcher';\nexport type { Fetch, ApiResponse, ApiRequest } from './config';\nexport { PayloadAction } from './native/types';\n\nconst INITIAL_RETRY_INTERVAL = 5000;\nconst MAXIMUM_RETRY_INTERVAL = 1000 * 60 * 60; // 1 hour\n\nexport default function createClient(\n  setStatus: (status?: TokenStatus) => void,\n  initialConfig: InitialConfig\n) {\n  const { safetyNetApiKey } = initialConfig;\n  let currentStatus: TokenStatus | undefined;\n  let currentAccountId: string | undefined;\n  setupLogger({\n    infoLogger: initialConfig.infoLogger,\n    errorLogger: initialConfig.errorLogger,\n  });\n\n  async function reattest(\n    tokenId: string,\n    nonce: string\n  ): Promise<Attestation> {\n    if (!currentAccountId) {\n      const error = new Error(\n        `Tried to reattest ${tokenId}, but no account id set.`\n      );\n      logger.error(undefined, error, undefined);\n      throw error;\n    }\n\n    return getReattestation(currentAccountId, tokenId, nonce);\n  }\n\n  const config = getConfigFromInitialConfig(initialConfig);\n  const fetcher = createFetcher(config, reattest);\n  const abtTokensService = createAbtTokensService(fetcher, config.hosts);\n\n  const toVisualState = (storedState: StoredState): VisualState => {\n    if (storedState.error?.missingNetConnection) {\n      return 'MissingNetConnection';\n    } else if (storedState.error) {\n      return 'Error';\n    } else if (\n      storedState.state === 'Validating' ||\n      storedState.state === 'Valid'\n    ) {\n      return 'Token';\n    } else {\n      return 'Loading';\n    }\n  };\n  let currentRetryInterval = INITIAL_RETRY_INTERVAL;\n  let scheduledRetry: NodeJS.Timeout | undefined;\n\n  const scheduleRetry = () => {\n    scheduledRetry = setTimeout(\n      () =>\n        startTokenStateMachine(\n          abtTokensService,\n          setStatusWrapper,\n          safetyNetApiKey,\n          false,\n          currentAccountId\n        ),\n      currentRetryInterval\n    );\n    // Exponential backoff for timeout interval capped to maximum of one hour\n    currentRetryInterval = Math.min(\n      currentRetryInterval * 2,\n      MAXIMUM_RETRY_INTERVAL\n    );\n  };\n\n  const unscheduleRetry = () => {\n    if (scheduledRetry) {\n      clearTimeout(scheduledRetry);\n    }\n    currentRetryInterval = INITIAL_RETRY_INTERVAL;\n  };\n\n  const setStatusWrapper = (storedState?: StoredState) => {\n    // Do not give status callbacks for other accounts ids than the one\n    // currently set\n    if (storedState?.accountId && storedState.accountId !== currentAccountId) {\n      return;\n    }\n\n    const status = storedState && {\n      tokenId: 'tokenId' in storedState ? storedState.tokenId : undefined,\n      state: storedState.state,\n      error: sanitizeError(storedState.error),\n      visualState: toVisualState(storedState),\n    };\n    currentStatus = status;\n    setStatus(status);\n\n    if (status?.error) {\n      scheduleRetry();\n    } else if (storedState?.state === 'Valid') {\n      unscheduleRetry();\n    }\n  };\n\n  return {\n    setAccount(accountId: string | undefined) {\n      if (currentAccountId !== accountId) {\n        currentAccountId = accountId;\n        unscheduleRetry();\n        startTokenStateMachine(\n          abtTokensService,\n          setStatusWrapper,\n          safetyNetApiKey,\n          false,\n          accountId\n        );\n      }\n    },\n    retry: (forceRestart: boolean) => {\n      if (!currentAccountId) {\n        return;\n      }\n\n      if (!forceRestart && currentStatus?.visualState === 'Loading') {\n        return;\n      }\n\n      unscheduleRetry();\n      startTokenStateMachine(\n        abtTokensService,\n        setStatusWrapper,\n        safetyNetApiKey,\n        forceRestart,\n        currentAccountId\n      );\n    },\n    toggleToken: async (tokenId: string): Promise<StoredToken[]> => {\n      if (!currentAccountId) {\n        const error = new Error(\n          'Only able to toggle valid tokens on active account'\n        );\n        logger.error(undefined, error, undefined);\n        return Promise.reject(error);\n      }\n\n      const { tokens } = await abtTokensService.toggleToken(tokenId, {\n        overrideExisting: true,\n      });\n\n      return tokens;\n    },\n    listTokens: async (): Promise<StoredToken[] | undefined> => {\n      if (!currentAccountId) {\n        const error = new Error('No active account');\n        logger.error(undefined, error, undefined);\n        return Promise.reject(error);\n      }\n\n      return await abtTokensService.listTokens();\n    },\n\n    /**\n     * Get a secure token for the current active token on the current account.\n     *\n     * If no account set, or if the current token visual state is not 'Token',\n     * undefined will be returned.\n     *\n     * You must specify the actions the secure token should be used for. For\n     * example creating a qr code for inspection needs the 'ticketInspection'\n     * action, and to retrieve fare contracts the 'getFarecontracts' is\n     * necessary.\n     *\n     * @param actions the actions the created token may be used for\n     * @return {Promise} a Promise for getting the secure token for the given\n     * action\n     */\n    getSecureToken: async (\n      actions: PayloadAction[]\n    ): Promise<string | undefined> => {\n      if (!currentAccountId || currentStatus?.visualState !== 'Token') {\n        return Promise.resolve(undefined);\n      }\n\n      const token = await getToken(currentAccountId);\n\n      if (!token) {\n        const error = new Error(\n          `Token not found for account '${currentAccountId}'`\n        );\n        logger.error(undefined, error, undefined);\n        return Promise.reject(error);\n      }\n\n      return getSecureToken(currentAccountId, token.tokenId, true, actions);\n    },\n  };\n}\n\nconst sanitizeError = (error?: TokenError) => {\n  if (!error) return undefined;\n\n  const newErr = new Error(\n    typeof error.err === 'string' ? error.err : error.err?.message\n  );\n\n  newErr.name = error.err?.name;\n  newErr.stack = error.err?.stack;\n\n  return {\n    ...error,\n    err: newErr,\n  };\n};\n"]}