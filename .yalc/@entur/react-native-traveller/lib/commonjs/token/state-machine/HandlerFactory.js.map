{"version":3,"sources":["HandlerFactory.ts"],"names":["stateHandlerFactory","forStates","handlerFunction","storedState","includes","state","error","type","message","catch","err"],"mappings":";;;;;;;AAIO,SAASA,mBAAT,CACLC,SADK,EAELC,eAFK,EAKS;AACd,SAAO,MAAOC,WAAP,IAA0D;AAC/D,QAAI,CAACF,SAAS,CAACG,QAAV,CAAmBD,WAAW,CAACE,KAA/B,CAAL,EAAiD;AAC/C,aAAO,EACL,GAAGF,WADE;AAELG,QAAAA,KAAK,EAAE;AACLC,UAAAA,IAAI,EAAE,QADD;AAELC,UAAAA,OAAO,EAAG,wBAAuBP,SAAU,6BAA4BE,WAAW,CAACE,KAAM;AAFpF;AAFF,OAAP;AAOD;;AAED,WAAOH,eAAe,CAACC,WAAD,CAAf,CAA2DM,KAA3D,CACJC,GAAD,IAAS;AACP,aAAO,EACL,GAAGP,WADE;AAELG,QAAAA,KAAK,EAAE;AACLC,UAAAA,IAAI,EAAE,SADD;AAELC,UAAAA,OAAO,EAAG,kCAAiCL,WAAW,CAACE,KAAM,EAFxD;AAGLK,UAAAA;AAHK;AAFF,OAAP;AAQD,KAVI,CAAP;AAYD,GAvBD;AAwBD","sourcesContent":["import type { StoredState, TokenState } from '../types';\n\nexport type StateHandler = (storedState: StoredState) => Promise<StoredState>;\n\nexport function stateHandlerFactory<S extends TokenState>(\n  forStates: S[],\n  handlerFunction: (\n    storedState: StoredState & { state: S }\n  ) => Promise<StoredState>\n): StateHandler {\n  return async (storedState: StoredState): Promise<StoredState> => {\n    if (!forStates.includes(storedState.state as S)) {\n      return {\n        ...storedState,\n        error: {\n          type: 'Severe',\n          message: `Applying handler for ${forStates} when the actual state is ${storedState.state}`,\n        },\n      };\n    }\n\n    return handlerFunction(storedState as StoredState & { state: S }).catch(\n      (err) => {\n        return {\n          ...storedState,\n          error: {\n            type: 'Unknown',\n            message: `Error during handling of state ${storedState.state}`,\n            err,\n          },\n        };\n      }\n    );\n  };\n}\n"]}