{"version":3,"sources":["fetcher.ts"],"names":["RequestError","Error","constructor","response","message","status","captureStackTrace","name","createInternalFetcher","config","request","fetch","headers","extraHeaders","isOk","createFetcher","fetcher","handleRequest","allowRetry","error","req"],"mappings":";;AAEA,OAAO,MAAMA,YAAN,SAA2BC,KAA3B,CAAiC;AAGtCC,EAAAA,WAAW,CAACC,QAAD,EAAwB;AACjC,UAAMC,OAAO,GAAI,GAAED,QAAQ,CAACE,MAAO,EAAnC,CADiC,CACK;;AACtC,UAAMD,OAAN,EAFiC,CAIjC;;AAJiC;;AAKjC,QAAIH,KAAK,CAACK,iBAAV,EAA6B;AAC3BL,MAAAA,KAAK,CAACK,iBAAN,CAAwB,IAAxB,EAA8BN,YAA9B;AACD;;AAED,SAAKO,IAAL,GAAY,cAAZ;AACA,SAAKJ,QAAL,GAAgBA,QAAhB;AACD;;AAdqC;;AAiBxC,SAASK,qBAAT,CAA+BC,MAA/B,EAAsD;AACpD,SAAO,MAAUC,OAAV,IAAkC;AACvC,UAAMP,QAAQ,GAAG,MAAMM,MAAM,CAACE,KAAP,CAAgB,EACrC,GAAGD,OADkC;AAErCE,MAAAA,OAAO,EAAE,EACP,IAAGH,MAAH,aAAGA,MAAH,uBAAGA,MAAM,CAAEI,YAAX,CADO;AAEP,YAAGH,OAAH,aAAGA,OAAH,uBAAGA,OAAO,CAAEE,OAAZ;AAFO;AAF4B,KAAhB,CAAvB;;AAQA,QAAI,CAACE,IAAI,CAACX,QAAD,CAAT,EAAqB;AACnB,YAAM,IAAIH,YAAJ,CAAiBG,QAAjB,CAAN;AACD;;AAED,WAAOA,QAAP;AACD,GAdD;AAeD;;AAED,OAAO,SAASY,aAAT,CAAuBN,MAAvB,EAA8C;AACnD,QAAMO,OAAO,GAAGR,qBAAqB,CAACC,MAAD,CAArC;;AAEA,QAAMQ,aAAa,GAAG,OACpBP,OADoB,EAEpBQ,UAAU,GAAG,IAFO,KAGQ;AAC5B,QAAI;AACF,aAAO,MAAMF,OAAO,CAAIN,OAAJ,CAApB;AACD,KAFD,CAEE,OAAOS,KAAP,EAAc;AACd,UAAIA,KAAK,YAAYnB,YAArB,EAAmC;AACjC,YAAIkB,UAAJ,EAAgB;AACd,iBAAOD,aAAa,CAACP,OAAD,EAAU,KAAV,CAApB;AACD;AACF;;AACD,YAAMS,KAAN;AACD;AACF,GAdD;;AAgBA,SAAQC,GAAD,IAAqBH,aAAa,CAACG,GAAD,EAAM,IAAN,CAAzC;AACD;;AAED,SAASN,IAAT,CAAcX,QAAd,EAAqC;AACnC,SAAOA,QAAQ,CAACE,MAAT,GAAkB,GAAlB,IAAyBF,QAAQ,CAACE,MAAT,GAAkB,GAAlD;AACD","sourcesContent":["import type { ApiRequest, ApiResponse, Config, Fetch } from './config';\n\nexport class RequestError extends Error {\n  response: ApiResponse;\n\n  constructor(response: ApiResponse) {\n    const message = `${response.status}`; //: ${response.statusText}`;\n    super(message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, RequestError);\n    }\n\n    this.name = 'RequestError';\n    this.response = response;\n  }\n}\n\nfunction createInternalFetcher(config: Config): Fetch {\n  return async <T>(request: ApiRequest) => {\n    const response = await config.fetch<T>({\n      ...request,\n      headers: {\n        ...config?.extraHeaders,\n        ...request?.headers,\n      },\n    });\n\n    if (!isOk(response)) {\n      throw new RequestError(response);\n    }\n\n    return response;\n  };\n}\n\nexport function createFetcher(config: Config): Fetch {\n  const fetcher = createInternalFetcher(config);\n\n  const handleRequest = async <T>(\n    request: ApiRequest,\n    allowRetry = true\n  ): Promise<ApiResponse<T>> => {\n    try {\n      return await fetcher<T>(request);\n    } catch (error) {\n      if (error instanceof RequestError) {\n        if (allowRetry) {\n          return handleRequest(request, false);\n        }\n      }\n      throw error;\n    }\n  };\n\n  return (req: ApiRequest) => handleRequest(req, true);\n}\n\nfunction isOk(response: ApiResponse) {\n  return response.status > 199 && response.status < 300;\n}\n"]}