{"version":3,"sources":["fetcher.ts"],"names":["base64","utf8","logger","RequestError","Error","constructor","response","message","status","captureStackTrace","name","createInternalFetcher","config","request","fetch","headers","extraHeaders","isOk","createFetcher","reattest","fetcher","handleRequest","allowRetry","error","errorResponseData","data","isReattestationError","token_id","nonce","metadata","info","undefined","tokenId","reattestBody","jsonBody","JSON","stringify","utf8value","encode","headerValue","req","code"],"mappings":"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","sourcesContent":["import type { ApiRequest, ApiResponse, Config, Fetch } from './config';\nimport type { Attestation } from './token/types';\nimport base64 from 'base-64';\nimport utf8 from 'utf8';\nimport { logger } from './logger';\n\nexport class RequestError extends Error {\n  response: ApiResponse;\n\n  constructor(response: ApiResponse) {\n    const message = `${response.status}`; //: ${response.statusText}`;\n    super(message);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, RequestError);\n    }\n\n    this.name = 'RequestError';\n    this.response = response;\n  }\n}\n\ntype ErrorResponse = {\n  code: string;\n  message: string;\n  metadata: any;\n};\n\ntype ReattestationData = {\n  token_id: string;\n  nonce: string;\n  attestation_encryption_public_key: string;\n};\n\nfunction createInternalFetcher(config: Config): Fetch {\n  return async <T>(request: ApiRequest) => {\n    const response = await config.fetch<T>({\n      ...request,\n      headers: {\n        ...config?.extraHeaders,\n        ...request?.headers,\n      },\n    });\n\n    if (!isOk(response)) {\n      throw new RequestError(response);\n    }\n\n    return response;\n  };\n}\n\ntype ReattestFunction = (\n  tokenId: string,\n  nonce: string\n) => Promise<Attestation>;\n\nexport function createFetcher(\n  config: Config,\n  reattest: ReattestFunction\n): Fetch {\n  const fetcher = createInternalFetcher(config);\n\n  const handleRequest = async <T>(\n    request: ApiRequest,\n    allowRetry = true\n  ): Promise<ApiResponse<T>> => {\n    try {\n      return await fetcher<T>(request);\n    } catch (error: any) {\n      const errorResponseData = error?.response?.data;\n      if (isReattestationError(errorResponseData)) {\n        const {\n          token_id,\n          nonce,\n        }: ReattestationData = errorResponseData.metadata;\n        logger.info('mobiletoken_reattestation_required', undefined, {\n          tokenId: token_id,\n        });\n        const reattestBody = await reattest(token_id, nonce);\n\n        const jsonBody = JSON.stringify(reattestBody);\n        const utf8value = utf8.encode(jsonBody);\n        const headerValue = base64.encode(utf8value);\n\n        const headers: Record<string, string> = request.headers ?? {};\n\n        headers['X-Attestation-Data'] = headerValue;\n        request.headers = headers;\n\n        return handleRequest(request, true);\n      }\n\n      logger.error(undefined, error, undefined);\n\n      if (error instanceof RequestError) {\n        if (allowRetry) {\n          return handleRequest(request, false);\n        }\n      }\n      throw error;\n    }\n  };\n\n  return (req: ApiRequest) => handleRequest(req, true);\n}\n\nfunction isOk(response: ApiResponse) {\n  return response.status > 199 && response.status < 300;\n}\n\nconst isReattestationError = (data: any): data is ErrorResponse => {\n  return data?.code === 'REATTESTATION_REQUIRED';\n};\n"]}