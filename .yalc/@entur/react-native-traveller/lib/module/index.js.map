{"version":3,"sources":["index.ts"],"names":["getConfigFromInitialConfig","startTokenStateMachine","createFetcher","createAbtTokensService","getSecureToken","getToken","RequestError","PayloadAction","INITIAL_RETRY_INTERVAL","MAXIMUM_RETRY_INTERVAL","createClient","setStatus","initialConfig","safetyNetApiKey","config","fetcher","abtTokensService","hosts","currentStatus","currentAccountId","toVisualState","storedState","error","missingNetConnection","state","isInspectable","currentRetryInterval","scheduledRetry","scheduleRetry","setTimeout","setStatusWrapper","Math","min","unscheduleRetry","clearTimeout","accountId","status","sanitizeError","visualState","setAccount","retry","forceRestart","toggleToken","tokenId","Promise","reject","Error","tokens","overrideExisting","listTokens","actions","resolve","undefined","token","newErr","err","message","name","stack"],"mappings":"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","sourcesContent":["import { getConfigFromInitialConfig, InitialConfig } from './config';\nimport { startTokenStateMachine } from './token';\nimport { createFetcher } from './fetcher';\nimport { createAbtTokensService } from './token/abt-tokens-service';\nimport type {\n  StoredState,\n  StoredToken,\n  TokenError,\n  TokenStatus,\n  VisualState,\n} from './token/types';\nimport { getSecureToken, getToken } from './native';\nimport type { PayloadAction } from './native/types';\n\nexport type { StoredToken } from './token/types';\nexport type { Token } from './native/types';\nexport { RequestError } from './fetcher';\nexport type { Fetch, ApiResponse, ApiRequest } from './config';\nexport { PayloadAction } from './native/types';\n\nconst INITIAL_RETRY_INTERVAL = 5000;\nconst MAXIMUM_RETRY_INTERVAL = 1000 * 60 * 60; // 1 hour\n\nexport default function createClient(\n  setStatus: (status?: TokenStatus) => void,\n  initialConfig: InitialConfig\n) {\n  const { safetyNetApiKey } = initialConfig;\n  const config = getConfigFromInitialConfig(initialConfig);\n  const fetcher = createFetcher(config);\n  const abtTokensService = createAbtTokensService(fetcher, config.hosts);\n\n  let currentStatus: TokenStatus | undefined;\n  let currentAccountId: string | undefined;\n\n  const toVisualState = (storedState: StoredState): VisualState => {\n    if (storedState.error?.missingNetConnection) {\n      return 'MissingNetConnection';\n    } else if (storedState.error) {\n      return 'Error';\n    } else if (storedState.state === 'Validating') {\n      return 'Token';\n    } else if (storedState.state === 'Valid') {\n      return storedState.isInspectable ? 'Token' : 'NotInspectable';\n    } else {\n      return 'Loading';\n    }\n  };\n  let currentRetryInterval = INITIAL_RETRY_INTERVAL;\n  let scheduledRetry: NodeJS.Timeout | undefined;\n\n  const scheduleRetry = () => {\n    scheduledRetry = setTimeout(\n      () =>\n        startTokenStateMachine(\n          abtTokensService,\n          setStatusWrapper,\n          safetyNetApiKey,\n          false,\n          currentAccountId\n        ),\n      currentRetryInterval\n    );\n    // Exponential backoff for timeout interval capped to maximum of one hour\n    currentRetryInterval = Math.min(\n      currentRetryInterval * 2,\n      MAXIMUM_RETRY_INTERVAL\n    );\n  };\n\n  const unscheduleRetry = () => {\n    if (scheduledRetry) {\n      clearTimeout(scheduledRetry);\n    }\n    currentRetryInterval = INITIAL_RETRY_INTERVAL;\n  };\n\n  const setStatusWrapper = (storedState?: StoredState) => {\n    // Do not give status callbacks for other accounts ids than the one\n    // currently set\n    if (storedState?.accountId && storedState.accountId !== currentAccountId) {\n      return;\n    }\n\n    const status = storedState && {\n      state: storedState.state,\n      error: sanitizeError(storedState.error),\n      visualState: toVisualState(storedState),\n    };\n    currentStatus = status;\n    setStatus(status);\n\n    if (status?.error) {\n      scheduleRetry();\n    } else if (storedState?.state === 'Valid') {\n      unscheduleRetry();\n    }\n  };\n\n  return {\n    setAccount(accountId: string | undefined) {\n      if (currentAccountId !== accountId) {\n        currentAccountId = accountId;\n        unscheduleRetry();\n        startTokenStateMachine(\n          abtTokensService,\n          setStatusWrapper,\n          safetyNetApiKey,\n          false,\n          accountId\n        );\n      }\n    },\n    retry: (forceRestart: boolean) => {\n      if (!currentAccountId) {\n        return;\n      }\n\n      if (!forceRestart && currentStatus?.visualState === 'Loading') {\n        return;\n      }\n\n      unscheduleRetry();\n      startTokenStateMachine(\n        abtTokensService,\n        setStatusWrapper,\n        safetyNetApiKey,\n        forceRestart,\n        currentAccountId\n      );\n    },\n    toggleToken: async (tokenId: string): Promise<StoredToken[]> => {\n      if (!currentAccountId) {\n        return Promise.reject(\n          new Error('Only able to toggle valid tokens on active account')\n        );\n      }\n\n      const { tokens } = await abtTokensService.toggleToken(tokenId, {\n        overrideExisting: true,\n      });\n\n      return tokens;\n    },\n    listTokens: async (): Promise<StoredToken[] | undefined> => {\n      if (!currentAccountId) {\n        return Promise.reject(new Error('No active account'));\n      }\n\n      return await abtTokensService.listTokens();\n    },\n\n    /**\n     * Get a secure token for the current active token on the current account.\n     *\n     * If no account set, or if the current token visual state is not 'Token',\n     * undefined will be returned.\n     *\n     * You must specify the actions the secure token should be used for. For\n     * example creating a qr code for inspection needs the 'ticketInspection'\n     * action, and to retrieve fare contracts the 'getFarecontracts' is\n     * necessary.\n     *\n     * @param actions the actions the created token may be used for\n     * @return {Promise} a Promise for getting the secure token for the given\n     * action\n     */\n    getSecureToken: async (\n      actions: PayloadAction[]\n    ): Promise<string | undefined> => {\n      if (!currentAccountId || currentStatus?.visualState !== 'Token') {\n        return Promise.resolve(undefined);\n      }\n\n      const token = await getToken(currentAccountId);\n\n      if (!token) {\n        return Promise.reject(new Error('Token not found'));\n      }\n\n      return getSecureToken(currentAccountId, token.tokenId, true, actions);\n    },\n  };\n}\n\nconst sanitizeError = (error?: TokenError) => {\n  if (!error) return undefined;\n\n  const newErr = new Error(\n    typeof error.err === 'string' ? error.err : error.err?.message\n  );\n\n  newErr.name = error.err?.name;\n  newErr.stack = error.err?.stack;\n\n  return {\n    ...error,\n    err: newErr,\n  };\n};\n"]}