{"version":3,"sources":["index.ts"],"names":["getConfigFromInitialConfig","startTokenStateMachine","createFetcher","createAbtTokensService","getSecureToken","getToken","getActivateTokenRequestBody","setupLogger","logger","RequestError","PayloadAction","INITIAL_RETRY_INTERVAL","MAXIMUM_RETRY_INTERVAL","createClient","setStatus","initialConfig","safetyNetApiKey","currentStatus","currentAccountId","infoLogger","errorLogger","reattest","tokenId","nonce","attestationEncryptionPublicKey","error","Error","undefined","config","fetcher","abtTokensService","hosts","toVisualState","storedState","missingNetConnection","state","currentRetryInterval","scheduledRetry","scheduleRetry","setTimeout","setStatusWrapper","Math","min","unscheduleRetry","clearTimeout","accountId","status","sanitizeError","visualState","setAccount","retry","forceRestart","toggleToken","Promise","reject","tokens","overrideExisting","listTokens","actions","resolve","token","newErr","err","message","name","stack"],"mappings":"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","sourcesContent":["import { getConfigFromInitialConfig, InitialConfig } from './config';\nimport { startTokenStateMachine } from './token';\nimport { createFetcher } from './fetcher';\nimport { createAbtTokensService } from './token/abt-tokens-service';\nimport type {\n  ActivateTokenRequest,\n  StoredState,\n  StoredToken,\n  TokenError,\n  TokenStatus,\n  VisualState,\n} from './token/types';\nimport { getSecureToken, getToken } from './native';\nimport type { PayloadAction } from './native/types';\nimport { getActivateTokenRequestBody } from './token/attest';\nimport { setupLogger, logger } from './logger';\n\nexport type { StoredToken } from './token/types';\nexport type { Token } from './native/types';\nexport { RequestError } from './fetcher';\nexport type { Fetch, ApiResponse, ApiRequest } from './config';\nexport { PayloadAction } from './native/types';\n\nconst INITIAL_RETRY_INTERVAL = 5000;\nconst MAXIMUM_RETRY_INTERVAL = 1000 * 60 * 60; // 1 hour\n\nexport default function createClient(\n  setStatus: (status?: TokenStatus) => void,\n  initialConfig: InitialConfig\n) {\n  const { safetyNetApiKey } = initialConfig;\n  let currentStatus: TokenStatus | undefined;\n  let currentAccountId: string | undefined;\n  setupLogger({\n    infoLogger: initialConfig.infoLogger,\n    errorLogger: initialConfig.errorLogger,\n  });\n\n  async function reattest(\n    tokenId: string,\n    nonce: string,\n    attestationEncryptionPublicKey: string\n  ): Promise<ActivateTokenRequest> {\n    if (!currentAccountId) {\n      const error = new Error(\n        `Tried to reattest ${tokenId}, but no account id set.`\n      );\n      logger.error(undefined, error, undefined);\n      throw error;\n    }\n\n    return getActivateTokenRequestBody(\n      currentAccountId,\n      tokenId,\n      nonce,\n      attestationEncryptionPublicKey\n    );\n  }\n\n  const config = getConfigFromInitialConfig(initialConfig);\n  const fetcher = createFetcher(config, reattest);\n  const abtTokensService = createAbtTokensService(fetcher, config.hosts);\n\n  const toVisualState = (storedState: StoredState): VisualState => {\n    if (storedState.error?.missingNetConnection) {\n      return 'MissingNetConnection';\n    } else if (storedState.error) {\n      return 'Error';\n    } else if (\n      storedState.state === 'Validating' ||\n      storedState.state === 'Valid'\n    ) {\n      return 'Token';\n    } else {\n      return 'Loading';\n    }\n  };\n  let currentRetryInterval = INITIAL_RETRY_INTERVAL;\n  let scheduledRetry: NodeJS.Timeout | undefined;\n\n  const scheduleRetry = () => {\n    scheduledRetry = setTimeout(\n      () =>\n        startTokenStateMachine(\n          abtTokensService,\n          setStatusWrapper,\n          safetyNetApiKey,\n          false,\n          currentAccountId\n        ),\n      currentRetryInterval\n    );\n    // Exponential backoff for timeout interval capped to maximum of one hour\n    currentRetryInterval = Math.min(\n      currentRetryInterval * 2,\n      MAXIMUM_RETRY_INTERVAL\n    );\n  };\n\n  const unscheduleRetry = () => {\n    if (scheduledRetry) {\n      clearTimeout(scheduledRetry);\n    }\n    currentRetryInterval = INITIAL_RETRY_INTERVAL;\n  };\n\n  const setStatusWrapper = (storedState?: StoredState) => {\n    // Do not give status callbacks for other accounts ids than the one\n    // currently set\n    if (storedState?.accountId && storedState.accountId !== currentAccountId) {\n      return;\n    }\n\n    const status = storedState && {\n      tokenId: 'tokenId' in storedState ? storedState.tokenId : undefined,\n      state: storedState.state,\n      error: sanitizeError(storedState.error),\n      visualState: toVisualState(storedState),\n    };\n    currentStatus = status;\n    setStatus(status);\n\n    if (status?.error) {\n      scheduleRetry();\n    } else if (storedState?.state === 'Valid') {\n      unscheduleRetry();\n    }\n  };\n\n  return {\n    setAccount(accountId: string | undefined) {\n      if (currentAccountId !== accountId) {\n        currentAccountId = accountId;\n        unscheduleRetry();\n        startTokenStateMachine(\n          abtTokensService,\n          setStatusWrapper,\n          safetyNetApiKey,\n          false,\n          accountId\n        );\n      }\n    },\n    retry: (forceRestart: boolean) => {\n      if (!currentAccountId) {\n        return;\n      }\n\n      if (!forceRestart && currentStatus?.visualState === 'Loading') {\n        return;\n      }\n\n      unscheduleRetry();\n      startTokenStateMachine(\n        abtTokensService,\n        setStatusWrapper,\n        safetyNetApiKey,\n        forceRestart,\n        currentAccountId\n      );\n    },\n    toggleToken: async (tokenId: string): Promise<StoredToken[]> => {\n      if (!currentAccountId) {\n        const error = new Error(\n          'Only able to toggle valid tokens on active account'\n        );\n        logger.error(undefined, error, undefined);\n        return Promise.reject(error);\n      }\n\n      const { tokens } = await abtTokensService.toggleToken(tokenId, {\n        overrideExisting: true,\n      });\n\n      return tokens;\n    },\n    listTokens: async (): Promise<StoredToken[] | undefined> => {\n      if (!currentAccountId) {\n        const error = new Error('No active account');\n        logger.error(undefined, error, undefined);\n        return Promise.reject(error);\n      }\n\n      return await abtTokensService.listTokens();\n    },\n\n    /**\n     * Get a secure token for the current active token on the current account.\n     *\n     * If no account set, or if the current token visual state is not 'Token',\n     * undefined will be returned.\n     *\n     * You must specify the actions the secure token should be used for. For\n     * example creating a qr code for inspection needs the 'ticketInspection'\n     * action, and to retrieve fare contracts the 'getFarecontracts' is\n     * necessary.\n     *\n     * @param actions the actions the created token may be used for\n     * @return {Promise} a Promise for getting the secure token for the given\n     * action\n     */\n    getSecureToken: async (\n      actions: PayloadAction[]\n    ): Promise<string | undefined> => {\n      if (!currentAccountId || currentStatus?.visualState !== 'Token') {\n        return Promise.resolve(undefined);\n      }\n\n      const token = await getToken(currentAccountId);\n\n      if (!token) {\n        const error = new Error(\n          `Token not found for account '${currentAccountId}'`\n        );\n        logger.error(undefined, error, undefined);\n        return Promise.reject(error);\n      }\n\n      return getSecureToken(currentAccountId, token.tokenId, true, actions);\n    },\n  };\n}\n\nconst sanitizeError = (error?: TokenError) => {\n  if (!error) return undefined;\n\n  const newErr = new Error(\n    typeof error.err === 'string' ? error.err : error.err?.message\n  );\n\n  newErr.name = error.err?.name;\n  newErr.stack = error.err?.stack;\n\n  return {\n    ...error,\n    err: newErr,\n  };\n};\n"]}