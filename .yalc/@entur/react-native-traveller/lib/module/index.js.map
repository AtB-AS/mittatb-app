{"version":3,"sources":["index.ts"],"names":["getConfigFromInitialConfig","startTokenStateMachine","createFetcher","createAbtTokensService","getSecureToken","PayloadAction","RequestError","createClient","setStatus","initialConfig","safetyNetApiKey","config","fetcher","abtTokensService","hosts","currentStatus","toVisualState","storedState","error","missingNetConnection","includes","state","setStatusWrapper","status","visualState","clientState","clientStateRetriever","setAccount","accountId","retry","forceRestart","Error","generateQrCode","ticketInspection"],"mappings":"AAAA,SAASA,0BAAT,QAA0D,UAA1D;AACA,SAASC,sBAAT,QAAuC,SAAvC;AACA,SAASC,aAAT,QAA8B,WAA9B;AACA,SAASC,sBAAT,QAAuC,4BAAvC;AAEA,SAASC,cAAT,QAA+B,UAA/B;AACA,SAASC,aAAT,QAA8B,gBAA9B;AAGA,SAASC,YAAT,QAA6B,WAA7B;AASA,eAAe,SAASC,YAAT,CACbC,SADa,EAEbC,aAFa,EAGb;AACA,QAAM;AAAEC,IAAAA;AAAF,MAAsBD,aAA5B;AACA,QAAME,MAAM,GAAGX,0BAA0B,CAACS,aAAD,CAAzC;AACA,QAAMG,OAAO,GAAGV,aAAa,CAACS,MAAD,CAA7B;AACA,QAAME,gBAAgB,GAAGV,sBAAsB,CAACS,OAAD,EAAUD,MAAM,CAACG,KAAjB,CAA/C;AAEA,MAAIC,aAAJ;;AAEA,QAAMC,aAAa,GAAIC,WAAD,IAA2C;AAAA;;AAC/D,8BAAIA,WAAW,CAACC,KAAhB,+CAAI,mBAAmBC,oBAAvB,EAA6C;AAC3C,aAAO,sBAAP;AACD,KAFD,MAEO,IAAIF,WAAW,CAACC,KAAhB,EAAuB;AAC5B,aAAO,OAAP;AACD,KAFM,MAEA,IAAI,CAAC,OAAD,EAAU,YAAV,EAAwBE,QAAxB,CAAiCH,WAAW,CAACI,KAA7C,CAAJ,EAAyD;AAC9D,aAAO,OAAP;AACD,KAFM,MAEA;AACL,aAAO,SAAP;AACD;AACF,GAVD;;AAYA,QAAMC,gBAAgB,GAAIL,WAAD,IAA+B;AACtD,UAAMM,MAAM,GAAGN,WAAW,IAAI;AAC5BI,MAAAA,KAAK,EAAEJ,WAAW,CAACI,KADS;AAE5BH,MAAAA,KAAK,EAAED,WAAW,CAACC,KAFS;AAG5BM,MAAAA,WAAW,EAAER,aAAa,CAACC,WAAD;AAHE,KAA9B;AAKAF,IAAAA,aAAa,GAAGQ,MAAhB;AACAf,IAAAA,SAAS,CAACe,MAAD,CAAT;AACD,GARD;;AAUA,MAAIE,WAAwB,GAAG,EAA/B;;AAEA,WAASC,oBAAT,GAAgC;AAC9B,WAAOD,WAAP;AACD;;AAED,SAAO;AACLE,IAAAA,UAAU,CAACC,SAAD,EAAgC;AACxCH,MAAAA,WAAW,GAAG,EAAE,GAAGA,WAAL;AAAkBG,QAAAA;AAAlB,OAAd;;AACA,UAAIH,WAAW,CAACG,SAAhB,EAA2B;AACzB3B,QAAAA,sBAAsB,CACpBY,gBADoB,EAEpBS,gBAFoB,EAGpBI,oBAHoB,EAIpBhB,eAJoB,EAKpB,KALoB,CAAtB;AAOD;AACF,KAZI;;AAaLmB,IAAAA,KAAK,EAAGC,YAAD,IAA2B;AAAA;;AAChC,YAAM;AAAEF,QAAAA;AAAF,UAAgBH,WAAtB;;AACA,UAAI,CAACG,SAAL,EAAgB;AACd,cAAM,IAAIG,KAAJ,CAAU,wBAAV,CAAN;AACD;;AAED,UAAI,mBAAAhB,aAAa,UAAb,wDAAeS,WAAf,MAA+B,SAAnC,EAA8C;AAC5C,cAAM,IAAIO,KAAJ,CAAU,gDAAV,CAAN;AACD;;AAED9B,MAAAA,sBAAsB,CACpBY,gBADoB,EAEpBS,gBAFoB,EAGpBI,oBAHoB,EAIpBhB,eAJoB,EAKpBoB,YALoB,CAAtB,CAVgC,CAgB7B;AACJ,KA9BI;AA+BLE,IAAAA,cAAc,EAAE,MAAM;AAAA;;AACpB,YAAM;AAAEJ,QAAAA;AAAF,UAAgBH,WAAtB;;AACA,UAAI,CAACG,SAAL,EAAgB;AACd,cAAM,IAAIG,KAAJ,CAAU,wBAAV,CAAN;AACD;;AAED,UAAI,oBAAAhB,aAAa,UAAb,0DAAeS,WAAf,MAA+B,OAAnC,EAA4C;AAC1C,cAAM,IAAIO,KAAJ,CACJ,uDADI,CAAN;AAGD;;AAED,aAAO3B,cAAc,CAACwB,SAAD,EAAY,CAACvB,aAAa,CAAC4B,gBAAf,CAAZ,CAArB;AACD;AA5CI,GAAP;AA8CD","sourcesContent":["import { getConfigFromInitialConfig, InitialConfig } from './config';\nimport { startTokenStateMachine } from './token';\nimport { createFetcher } from './fetcher';\nimport { createAbtTokensService } from './token/abt-tokens-service';\nimport type { StoredState, TokenStatus, VisualState } from './token/types';\nimport { getSecureToken } from './native';\nimport { PayloadAction } from './native/types';\n\nexport type { Token } from './native/types';\nexport { RequestError } from './fetcher';\nexport type { Fetch, ApiResponse, ApiRequest } from './config';\n\nexport type ClientState = {\n  accountId?: string;\n};\n\nexport type ClientStateRetriever = () => ClientState;\n\nexport default function createClient(\n  setStatus: (status?: TokenStatus) => void,\n  initialConfig: InitialConfig\n) {\n  const { safetyNetApiKey } = initialConfig;\n  const config = getConfigFromInitialConfig(initialConfig);\n  const fetcher = createFetcher(config);\n  const abtTokensService = createAbtTokensService(fetcher, config.hosts);\n\n  let currentStatus: TokenStatus | undefined;\n\n  const toVisualState = (storedState: StoredState): VisualState => {\n    if (storedState.error?.missingNetConnection) {\n      return 'MissingNetConnection';\n    } else if (storedState.error) {\n      return 'Error';\n    } else if (['Valid', 'Validating'].includes(storedState.state)) {\n      return 'Token';\n    } else {\n      return 'Loading';\n    }\n  };\n\n  const setStatusWrapper = (storedState?: StoredState) => {\n    const status = storedState && {\n      state: storedState.state,\n      error: storedState.error,\n      visualState: toVisualState(storedState),\n    };\n    currentStatus = status;\n    setStatus(status);\n  };\n\n  let clientState: ClientState = {};\n\n  function clientStateRetriever() {\n    return clientState;\n  }\n\n  return {\n    setAccount(accountId: string | undefined) {\n      clientState = { ...clientState, accountId };\n      if (clientState.accountId) {\n        startTokenStateMachine(\n          abtTokensService,\n          setStatusWrapper,\n          clientStateRetriever,\n          safetyNetApiKey,\n          false\n        );\n      }\n    },\n    retry: (forceRestart: boolean) => {\n      const { accountId } = clientState;\n      if (!accountId) {\n        throw new Error('Account id must be set');\n      }\n\n      if (currentStatus?.visualState === 'Loading') {\n        throw new Error('Can not retry while the sdk is already running');\n      }\n\n      startTokenStateMachine(\n        abtTokensService,\n        setStatusWrapper,\n        clientStateRetriever,\n        safetyNetApiKey,\n        forceRestart\n      ); // Todo: Not start if already running\n    },\n    generateQrCode: () => {\n      const { accountId } = clientState;\n      if (!accountId) {\n        throw new Error('Account id must be set');\n      }\n\n      if (currentStatus?.visualState !== 'Token') {\n        throw new Error(\n          'The current state does not allow retrieval of qr code'\n        );\n      }\n\n      return getSecureToken(accountId, [PayloadAction.ticketInspection]);\n    },\n  };\n}\n"]}