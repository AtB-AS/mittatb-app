{"version":3,"sources":["index.ts"],"names":["getConfigFromInitialConfig","startTokenStateMachine","createFetcher","createAbtTokensService","getSecureToken","getToken","RequestError","PayloadAction","INITIAL_RETRY_INTERVAL","MAXIMUM_RETRY_INTERVAL","createClient","setStatus","initialConfig","safetyNetApiKey","config","fetcher","abtTokensService","hosts","currentStatus","currentAccountId","toVisualState","storedState","error","missingNetConnection","state","currentRetryInterval","scheduledRetry","scheduleRetry","setTimeout","setStatusWrapper","Math","min","unscheduleRetry","clearTimeout","accountId","status","tokenId","undefined","sanitizeError","visualState","setAccount","retry","forceRestart","toggleToken","Promise","reject","Error","tokens","overrideExisting","listTokens","actions","resolve","token","newErr","err","message","name","stack"],"mappings":"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","sourcesContent":["import { getConfigFromInitialConfig, InitialConfig } from './config';\nimport { startTokenStateMachine } from './token';\nimport { createFetcher } from './fetcher';\nimport { createAbtTokensService } from './token/abt-tokens-service';\nimport type {\n  StoredState,\n  StoredToken,\n  TokenError,\n  TokenStatus,\n  VisualState,\n} from './token/types';\nimport { getSecureToken, getToken } from './native';\nimport type { PayloadAction } from './native/types';\n\nexport type { StoredToken } from './token/types';\nexport type { Token } from './native/types';\nexport { RequestError } from './fetcher';\nexport type { Fetch, ApiResponse, ApiRequest } from './config';\nexport { PayloadAction } from './native/types';\n\nconst INITIAL_RETRY_INTERVAL = 5000;\nconst MAXIMUM_RETRY_INTERVAL = 1000 * 60 * 60; // 1 hour\n\nexport default function createClient(\n  setStatus: (status?: TokenStatus) => void,\n  initialConfig: InitialConfig\n) {\n  const { safetyNetApiKey } = initialConfig;\n  const config = getConfigFromInitialConfig(initialConfig);\n  const fetcher = createFetcher(config);\n  const abtTokensService = createAbtTokensService(fetcher, config.hosts);\n\n  let currentStatus: TokenStatus | undefined;\n  let currentAccountId: string | undefined;\n\n  const toVisualState = (storedState: StoredState): VisualState => {\n    if (storedState.error?.missingNetConnection) {\n      return 'MissingNetConnection';\n    } else if (storedState.error) {\n      return 'Error';\n    } else if (\n      storedState.state === 'Validating' ||\n      storedState.state === 'Valid'\n    ) {\n      return 'Token';\n    } else {\n      return 'Loading';\n    }\n  };\n  let currentRetryInterval = INITIAL_RETRY_INTERVAL;\n  let scheduledRetry: NodeJS.Timeout | undefined;\n\n  const scheduleRetry = () => {\n    scheduledRetry = setTimeout(\n      () =>\n        startTokenStateMachine(\n          abtTokensService,\n          setStatusWrapper,\n          safetyNetApiKey,\n          false,\n          currentAccountId\n        ),\n      currentRetryInterval\n    );\n    // Exponential backoff for timeout interval capped to maximum of one hour\n    currentRetryInterval = Math.min(\n      currentRetryInterval * 2,\n      MAXIMUM_RETRY_INTERVAL\n    );\n  };\n\n  const unscheduleRetry = () => {\n    if (scheduledRetry) {\n      clearTimeout(scheduledRetry);\n    }\n    currentRetryInterval = INITIAL_RETRY_INTERVAL;\n  };\n\n  const setStatusWrapper = (storedState?: StoredState) => {\n    // Do not give status callbacks for other accounts ids than the one\n    // currently set\n    if (storedState?.accountId && storedState.accountId !== currentAccountId) {\n      return;\n    }\n\n    const status = storedState && {\n      tokenId: 'tokenId' in storedState ? storedState.tokenId : undefined,\n      state: storedState.state,\n      error: sanitizeError(storedState.error),\n      visualState: toVisualState(storedState),\n    };\n    currentStatus = status;\n    setStatus(status);\n\n    if (status?.error) {\n      scheduleRetry();\n    } else if (storedState?.state === 'Valid') {\n      unscheduleRetry();\n    }\n  };\n\n  return {\n    setAccount(accountId: string | undefined) {\n      if (currentAccountId !== accountId) {\n        currentAccountId = accountId;\n        unscheduleRetry();\n        startTokenStateMachine(\n          abtTokensService,\n          setStatusWrapper,\n          safetyNetApiKey,\n          false,\n          accountId\n        );\n      }\n    },\n    retry: (forceRestart: boolean) => {\n      if (!currentAccountId) {\n        return;\n      }\n\n      if (!forceRestart && currentStatus?.visualState === 'Loading') {\n        return;\n      }\n\n      unscheduleRetry();\n      startTokenStateMachine(\n        abtTokensService,\n        setStatusWrapper,\n        safetyNetApiKey,\n        forceRestart,\n        currentAccountId\n      );\n    },\n    toggleToken: async (tokenId: string): Promise<StoredToken[]> => {\n      if (!currentAccountId) {\n        return Promise.reject(\n          new Error('Only able to toggle valid tokens on active account')\n        );\n      }\n\n      const { tokens } = await abtTokensService.toggleToken(tokenId, {\n        overrideExisting: true,\n      });\n\n      return tokens;\n    },\n    listTokens: async (): Promise<StoredToken[] | undefined> => {\n      if (!currentAccountId) {\n        return Promise.reject(new Error('No active account'));\n      }\n\n      return await abtTokensService.listTokens();\n    },\n\n    /**\n     * Get a secure token for the current active token on the current account.\n     *\n     * If no account set, or if the current token visual state is not 'Token',\n     * undefined will be returned.\n     *\n     * You must specify the actions the secure token should be used for. For\n     * example creating a qr code for inspection needs the 'ticketInspection'\n     * action, and to retrieve fare contracts the 'getFarecontracts' is\n     * necessary.\n     *\n     * @param actions the actions the created token may be used for\n     * @return {Promise} a Promise for getting the secure token for the given\n     * action\n     */\n    getSecureToken: async (\n      actions: PayloadAction[]\n    ): Promise<string | undefined> => {\n      if (!currentAccountId || currentStatus?.visualState !== 'Token') {\n        return Promise.resolve(undefined);\n      }\n\n      const token = await getToken(currentAccountId);\n\n      if (!token) {\n        return Promise.reject(new Error('Token not found'));\n      }\n\n      return getSecureToken(currentAccountId, token.tokenId, true, actions);\n    },\n  };\n}\n\nconst sanitizeError = (error?: TokenError) => {\n  if (!error) return undefined;\n\n  const newErr = new Error(\n    typeof error.err === 'string' ? error.err : error.err?.message\n  );\n\n  newErr.name = error.err?.name;\n  newErr.stack = error.err?.stack;\n\n  return {\n    ...error,\n    err: newErr,\n  };\n};\n"]}