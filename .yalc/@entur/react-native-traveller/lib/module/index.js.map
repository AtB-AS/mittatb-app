{"version":3,"sources":["index.ts"],"names":["getConfigFromInitialConfig","startTokenStateMachine","createFetcher","createAbtTokensService","getSecureToken","getToken","PayloadAction","RequestError","createClient","setStatus","initialConfig","safetyNetApiKey","config","fetcher","abtTokensService","hosts","currentStatus","currentAccountId","toVisualState","storedState","error","missingNetConnection","state","isInspectable","setStatusWrapper","accountId","status","sanitizeError","visualState","setAccount","retry","forceRestart","generateQrCode","Promise","resolve","undefined","token","reject","Error","tokenId","ticketInspection","newErr","err","message","name","stack"],"mappings":"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","sourcesContent":["import { getConfigFromInitialConfig, InitialConfig } from './config';\nimport { startTokenStateMachine } from './token';\nimport { createFetcher } from './fetcher';\nimport { createAbtTokensService } from './token/abt-tokens-service';\nimport type {\n  StoredState,\n  TokenError,\n  TokenStatus,\n  VisualState,\n} from './token/types';\nimport { getSecureToken, getToken } from './native';\nimport { PayloadAction } from './native/types';\n\nexport type { Token } from './native/types';\nexport { RequestError } from './fetcher';\nexport type { Fetch, ApiResponse, ApiRequest } from './config';\n\nexport default function createClient(\n  setStatus: (status?: TokenStatus) => void,\n  initialConfig: InitialConfig\n) {\n  const { safetyNetApiKey } = initialConfig;\n  const config = getConfigFromInitialConfig(initialConfig);\n  const fetcher = createFetcher(config);\n  const abtTokensService = createAbtTokensService(fetcher, config.hosts);\n\n  let currentStatus: TokenStatus | undefined;\n  let currentAccountId: string | undefined;\n\n  const toVisualState = (storedState: StoredState): VisualState => {\n    if (storedState.error?.missingNetConnection) {\n      return 'MissingNetConnection';\n    } else if (storedState.error) {\n      return 'Error';\n    } else if (storedState.state === 'Validating') {\n      return 'Token';\n    } else if (storedState.state === 'Valid') {\n      return storedState.isInspectable ? 'Token' : 'NotInspectable';\n    } else {\n      return 'Loading';\n    }\n  };\n\n  const setStatusWrapper = (storedState?: StoredState) => {\n    // Do not give status callbacks for other accounts ids than the one\n    // currently set\n    if (storedState?.accountId && storedState.accountId !== currentAccountId) {\n      return;\n    }\n\n    const status = storedState && {\n      state: storedState.state,\n      error: sanitizeError(storedState.error),\n      visualState: toVisualState(storedState),\n    };\n    currentStatus = status;\n    setStatus(status);\n  };\n\n  return {\n    setAccount(accountId: string | undefined) {\n      if (currentAccountId !== accountId) {\n        currentAccountId = accountId;\n        startTokenStateMachine(\n          abtTokensService,\n          setStatusWrapper,\n          safetyNetApiKey,\n          false,\n          accountId\n        );\n      }\n    },\n    retry: (forceRestart: boolean) => {\n      if (!currentAccountId) {\n        return;\n      }\n\n      if (!forceRestart && currentStatus?.visualState === 'Loading') {\n        return;\n      }\n\n      startTokenStateMachine(\n        abtTokensService,\n        setStatusWrapper,\n        safetyNetApiKey,\n        forceRestart,\n        currentAccountId\n      );\n    },\n    generateQrCode: async (): Promise<string | undefined> => {\n      if (!currentAccountId || currentStatus?.visualState !== 'Token') {\n        return Promise.resolve(undefined);\n      }\n\n      const token = await getToken(currentAccountId);\n\n      if (!token) {\n        return Promise.reject(new Error('Token not found'));\n      }\n\n      return getSecureToken(currentAccountId, token.tokenId, true, [\n        PayloadAction.ticketInspection,\n      ]);\n    },\n  };\n}\n\nconst sanitizeError = (error?: TokenError) => {\n  if (!error) return undefined;\n\n  const newErr = new Error(\n    typeof error.err === 'string' ? error.err : error.err?.message\n  );\n\n  newErr.name = error.err?.name;\n  newErr.stack = error.err?.stack;\n\n  return {\n    ...error,\n    err: newErr,\n  };\n};\n"]}