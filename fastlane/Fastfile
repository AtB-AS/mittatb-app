fastlane_version '2.142.0'

before_all do
  # ensure_git_status_clean
  # git_pull
end

def app_cert_info
  # App provisioning profile
  app_prefix = "#{ENV['IOS_BUNDLE_IDENTIFIER']}_#{ENV["FASTLANE_MATCH_TYPE"]}"
  app_prov_profile_path = ENV["sigh_#{app_prefix}_profile-path"]
  app_prov_profile_name = (ENV["sigh_#{app_prefix}_profile-name"]).gsub('\xC3\xB8', 'ø')
  app_signing_identity_name = (ENV["sigh_#{app_prefix}_certificate-name"]).gsub('\xC3\xB8', 'ø')

  return app_signing_identity_name, app_prov_profile_name, app_prov_profile_path
end

def widget_cert_info
  # Widget provisioning profile
  widget_prefix = "#{ENV['IOS_APP_WIDGET_IDENTIFIER']}_#{ENV["FASTLANE_MATCH_TYPE"]}"
  widget_prov_profile_path = ENV["sigh_#{widget_prefix}_profile-path"]
  widget_prov_profile_name = (ENV["sigh_#{widget_prefix}_profile-name"]).gsub('\xC3\xB8', 'ø')

  return widget_prov_profile_name, widget_prov_profile_path
end

def intent_cert_info
  # Intent provisioning profile
  intent_prefix = "#{ENV['IOS_APP_INTENT_IDENTIFIER']}_#{ENV["FASTLANE_MATCH_TYPE"]}"
  intent_prov_profile_path = ENV["sigh_#{intent_prefix}_profile-path"]
  intent_prov_profile_name = (ENV["sigh_#{intent_prefix}_profile-name"]).gsub('\xC3\xB8', 'ø')

  return intent_prov_profile_name, intent_prov_profile_path
end

platform :ios do
  desc 'Update new devices and provisioning profiles'
  lane :update_devices do
    ensure_env_vars(
      env_vars: [
        'FASTLANE_MATCH_GIT_SSH_URL',
        'IOS_DEVICES_FILE',
        'IOS_DEVELOPMENT_TEAM_ID',
        'IOS_BUNDLE_IDENTIFIER',
        'IOS_APP_WIDGET_IDENTIFIER',
        'IOS_APP_INTENT_IDENTIFIER',
        'FASTLANE_MATCH_TYPE',
        'APPCONNECT_API_KEY_PATH',
      ]
    )
    register_devices(
      team_id: ENV['IOS_DEVELOPMENT_TEAM_ID'],
      devices_file: ENV['IOS_DEVICES_FILE'],
      api_key_path: ENV['APPCONNECT_API_KEY_PATH'],
    )
    identifiers = [ENV['IOS_BUNDLE_IDENTIFIER'], ENV['IOS_APP_WIDGET_IDENTIFIER'], ENV['IOS_APP_INTENT_IDENTIFIER']]
    match(
      type: ENV["FASTLANE_MATCH_TYPE"],
      team_id: ENV['IOS_DEVELOPMENT_TEAM_ID'],
      git_url: ENV['FASTLANE_MATCH_GIT_SSH_URL'],
      storage_mode: 'git',
      app_identifier: identifiers,
      force_for_new_devices: true,
      force: true,
      git_user_email: ENV['FASTLANE_MATCH_USERNAME'],
    )
  end

  desc "Generate new certificates"
  lane :generate_new_certificates do
    ensure_env_vars(
      env_vars: ['IOS_DEVELOPMENT_TEAM_ID', 'IOS_BUNDLE_IDENTIFIER', 'IOS_APP_WIDGET_IDENTIFIER', 'IOS_APP_INTENT_IDENTIFIER', 'FASTLANE_MATCH_GIT_URL', 'FASTLANE_MATCH_TYPE']
    )
    identifiers = [ENV['IOS_BUNDLE_IDENTIFIER'], ENV['IOS_APP_WIDGET_IDENTIFIER'], ENV['IOS_APP_INTENT_IDENTIFIER']]
    match_nuke(
      readonly: false,
      team_id: ENV['IOS_DEVELOPMENT_TEAM_ID'],
      app_identifier: identifiers,
      git_url:ENV['FASTLANE_MATCH_GIT_URL'],
      type:ENV['FASTLANE_MATCH_TYPE'],
      skip_confirmation: true,
      username: ENV['FASTLANE_MATCH_USERNAME'],
    )
    get_certs
  end

  desc 'Generate new certificates without nuking old ones'
  lane :generate_new_certificates_without_nuke do
    ensure_env_vars(
      env_vars: ['MATCH_PASSWORD', 'FASTLANE_MATCH_GIT_SSH_URL', 'FASTLANE_MATCH_TYPE', 'IOS_BUNDLE_IDENTIFIER', 'IOS_APP_WIDGET_IDENTIFIER', 'IOS_APP_INTENT_IDENTIFIER', 'IOS_DEVELOPMENT_TEAM_ID']
    )
    identifiers = [ENV['IOS_BUNDLE_IDENTIFIER'], ENV['IOS_APP_WIDGET_IDENTIFIER'], ENV['IOS_APP_INTENT_IDENTIFIER']]
    match(
      type: ENV["FASTLANE_MATCH_TYPE"],
      app_identifier: identifiers,
      storage_mode: 'git',
      git_url: ENV['FASTLANE_MATCH_GIT_SSH_URL'],
      team_id: ENV['IOS_DEVELOPMENT_TEAM_ID'],
      readonly: false
    )
  end

  desc 'Match certificates'
  lane :get_certs do
    ensure_env_vars(
      env_vars: ['MATCH_PASSWORD', 'FASTLANE_MATCH_GIT_SSH_URL', 'FASTLANE_MATCH_TYPE', 'IOS_BUNDLE_IDENTIFIER', 'IOS_APP_WIDGET_IDENTIFIER', 'IOS_APP_INTENT_IDENTIFIER', 'IOS_DEVELOPMENT_TEAM_ID']
    )
    identifiers = [ENV['IOS_BUNDLE_IDENTIFIER'], ENV['IOS_APP_WIDGET_IDENTIFIER'], ENV['IOS_APP_INTENT_IDENTIFIER']]
    if is_ci
      create_keychain(
        name: "CI",
        password: ENV["MATCH_PASSWORD"],
        default_keychain: true,
        unlock: true,
        timeout: 10800,
        lock_when_sleeps: false
      )
      match(
        type: ENV["FASTLANE_MATCH_TYPE"],
        app_identifier: identifiers,
        storage_mode: 'git',
        git_url: ENV['FASTLANE_MATCH_GIT_SSH_URL'],
        readonly: true,
        keychain_name: "CI",
        keychain_password: ENV["MATCH_PASSWORD"],
        team_id: ENV['IOS_DEVELOPMENT_TEAM_ID']
      )
    else
      match(
        type: ENV["FASTLANE_MATCH_TYPE"],
        app_identifier: identifiers,
        storage_mode: 'git',
        git_url: ENV['FASTLANE_MATCH_GIT_SSH_URL'],
        team_id: ENV['IOS_DEVELOPMENT_TEAM_ID'],
        readonly: true
      )
    end
  end
  
  # iOS Lanes

  desc 'Setup certificates'
  lane :setup_certificates do
    get_certs

    ensure_env_vars(
      env_vars: ['FASTLANE_MATCH_TYPE', 'BUILD_CONFIGURATION', 'ENABLE_WIDGET', 'IOS_BUNDLE_IDENTIFIER', 'IOS_APP_WIDGET_IDENTIFIER', 'IOS_APP_INTENT_IDENTIFIER']
    )

    update_code_signing_settings(
      use_automatic_signing: false,
      path: "./ios/atb.xcodeproj"
    )
    
    app_signing_identity_name, app_prov_profile_name, app_prov_profile_path = app_cert_info

    widget_prov_profile_name, widget_prov_profile_path = widget_cert_info

    intent_prov_profile_name, intent_prov_profile_path = intent_cert_info

    puts "Identity name: #{app_signing_identity_name}"
    puts "Certificate names: #{app_prov_profile_name}, #{widget_prov_profile_name}, #{intent_prov_profile_name}"

    widget_enabled = ENV["ENABLE_WIDGET"] == "true"
    puts "Is widget enabled: #{widget_enabled}"

    update_project_team(
      path: "./ios/atb.xcodeproj",
      teamid: ENV["IOS_DEVELOPMENT_TEAM_ID"]
    )
    update_project_provisioning(
      xcodeproj: "./ios/atb.xcodeproj",
      target_filter: "app",
      profile: app_prov_profile_path,
      build_configuration: ENV['BUILD_CONFIGURATION'],
      code_signing_identity: app_signing_identity_name
    )
    if widget_enabled
      update_project_provisioning(
        xcodeproj: "./ios/atb.xcodeproj",
        target_filter: "departureWidget",
        profile: widget_prov_profile_path,
        build_configuration: ENV['BUILD_CONFIGURATION'],
        code_signing_identity: app_signing_identity_name
      )
      update_project_provisioning(
        xcodeproj: "./ios/atb.xcodeproj",
        target_filter: "AtbAppIntent",
        profile: intent_prov_profile_path,
        build_configuration: ENV['BUILD_CONFIGURATION'],
        code_signing_identity: app_signing_identity_name
      )
    end
  end

  desc 'Build the iOS application.'
  lane :build do
    ensure_env_vars(
      env_vars: ['BUILD_ID', 'EXPORT_METHOD', 'BUILD_CONFIGURATION']
    )
    increment_build_number(
      build_number: ENV["BUILD_ID"],
      xcodeproj: './ios/atb.xcodeproj/'
    )

    setup_certificates

    app_signing_identity_name, app_prov_profile_name, app_prov_profile_path = app_cert_info

    widget_prov_profile_name, widget_prov_profile_path = widget_cert_info

    intent_prov_profile_name, intent_prov_profile_path = intent_cert_info

    cocoapods(podfile: './ios/Podfile')
    build_app(
      scheme: 'atb',
      configuration: ENV['BUILD_CONFIGURATION'],
      export_method: ENV['EXPORT_METHOD'],
      workspace: './ios/atb.xcworkspace',
      export_options: {
        signingStyle: "manual",
        provisioningProfiles: {
          ENV['IOS_BUNDLE_IDENTIFIER'] => app_prov_profile_name,
          ENV['IOS_APP_WIDGET_IDENTIFIER'] => widget_prov_profile_name,
          ENV['IOS_APP_INTENT_IDENTIFIER'] => intent_prov_profile_name
      	}
      }
    )
  end

  desc 'Install pods.'
  lane :pods do
    cocoapods(podfile: './ios/Podfile')
  end

  desc 'Upload the build to Firebase App Distribution'
  lane :firebase_distribution_staging do
    ensure_env_vars(
      env_vars: ['FIREBASE_APP_ID_IOS','GCP_CREDENTIALS_PATH', 'APP_DISTRIBUTION_GROUP_NAME']
    )
    firebase_app_distribution(
      app:ENV['FIREBASE_APP_ID_IOS'],
      service_credentials_file:ENV['GCP_CREDENTIALS_PATH'],
      groups:ENV['APP_DISTRIBUTION_GROUP_NAME']
    )
  end

  desc 'Upload app to testflight'
  lane :testflight_prod do
    ensure_env_vars(
      env_vars: ['APPCONNECT_API_KEY_PATH']
    )
    pilot(
      api_key_path:ENV['APPCONNECT_API_KEY_PATH'],
      skip_waiting_for_build_processing:true,
    )
  end

  desc 'Upload the build to AppCenter'
  lane :appcenter_staging do
    ensure_env_vars(
      env_vars: ['APPCENTER_API_KEY']
    )
    appcenter_upload(
      api_token: ENV["APPCENTER_API_KEY"],
      owner_name: "AtB-AS",
      app_name: "MittAtb-1",
      owner_type: "organization",
      destinations: "*",
      file: "AtB.ipa",
      dsym: "AtB.app.dSYM.zip",
      notify_testers: true
    )
  end

  desc 'Upload the build to AppCenter for distribution to TestFlight'
  lane :appcenter_testflight do
    ensure_env_vars(
      env_vars: ['APPCENTER_API_KEY', 'RELEASE_NOTES', 'RELEASE_URL']
    )
    appcenter_upload(
      api_token: ENV["APPCENTER_API_KEY"],
      owner_name: "AtB-AS",
      app_name: "MittAtb-1",
      owner_type: "organization",
      file: "AtB.ipa",
      destination_type: "store",
      destinations: "AtB Internal",
      release_notes: ENV['RELEASE_NOTES'][0..3999],
      release_notes_link: ENV['RELEASE_URL']
    )
  end
end

platform :android do
  desc 'Upload the build to AppCenter'

  lane :build do
    ensure_env_vars(
      env_vars: ['BUILD_ID','KEYSTORE_PASS', 'KEY_ALIAS', 'KEY_PASS', 'APP_ENVIRONMENT', 'CI','KEYSTORE_PATH']
        )
    build_type = ENV['APP_ENVIRONMENT']
    gradle(task: 'clean', project_dir: 'android/')
    gradle(
      task: 'assemble',
      build_type: build_type,
      project_dir: 'android/',
      print_command: false, #don't print my passwords please
      properties: {
        "android.injected.signing.store.file" => File.expand_path(ENV["KEYSTORE_PATH"], Dir.pwd + "/../"),
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASS"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASS"],
      })
    sh("cp", "../android/app/build/outputs/apk/#{build_type}/app-#{build_type}.apk", "../")
    sh("mkdir", "-p", "../bundle")
    sh("cp", "../android/app/build/generated/assets/react/#{build_type}/index.android.bundle", "../bundle")
    sh("cp", "../android/app/build/intermediates/sourcemaps/react/#{build_type}/index.android.bundle.packager.map", "../bundle/index.android.bundle.map")
  end

  lane :build_aab do
    ensure_env_vars(
      env_vars: ['BUILD_ID','KEYSTORE_PASS', 'KEY_ALIAS', 'KEY_PASS', 'APP_ENVIRONMENT', 'CI','KEYSTORE_PATH']
    )
    build_type = ENV['APP_ENVIRONMENT']
    gradle(task: 'clean', project_dir: 'android/')
    gradle(
      task: 'bundle',
      build_type: build_type,
      project_dir: 'android/',
      print_command: false, #don't print my passwords please
      properties: {
        "android.injected.signing.store.file" => File.expand_path(ENV["KEYSTORE_PATH"], Dir.pwd + "/../"),
        "android.injected.signing.store.password" => ENV["KEYSTORE_PASS"],
        "android.injected.signing.key.alias" => ENV["KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["KEY_PASS"],
      })
    sh("cp", "../android/app/build/outputs/bundle/#{build_type}/app-#{build_type}.aab", "../")
    sh("mkdir", "-p", "../bundle")
    sh("cp", "../android/app/build/generated/assets/react/#{build_type}/index.android.bundle", "../bundle")
    sh("cp", "../android/app/build/intermediates/sourcemaps/react/#{build_type}/index.android.bundle.packager.map", "../bundle/index.android.bundle.map")
  end

  lane :firebase_distribution_staging do
    ensure_env_vars(
      env_vars: ['FIREBASE_APP_ID','GCP_CREDENTIALS_PATH','APK_FILE_NAME']
    )
    firebase_app_distribution(
      app:ENV['FIREBASE_APP_ID'],
      service_credentials_file:ENV['GCP_CREDENTIALS_PATH'],
      android_artifact_type:'APK',
      android_artifact_path:ENV['APK_FILE_NAME'],
      groups:ENV['APP_DISTRIBUTION_GROUP_NAME']
    )
  end

  lane :playstore_internal do
    ensure_env_vars(
      env_vars: ['GOOGLE_PLAY_SERVICE_ACCOUNT_PATH','APK_FILE_NAME','ANDROID_PACKAGE_NAME']
    )

    upload_to_play_store(
      track: "internal",
      json_key:ENV['GOOGLE_PLAY_SERVICE_ACCOUNT_PATH'],
      apk: ENV['APK_FILE_NAME'],
      package_name: ENV['ANDROID_PACKAGE_NAME']
    )
  end

  lane :playstore_internal_aab do
    ensure_env_vars(
      env_vars: ['GOOGLE_PLAY_SERVICE_ACCOUNT_PATH','AAB_FILE_NAME','ANDROID_PACKAGE_NAME']
    )

    upload_to_play_store(
      track: "internal",
      json_key: ENV['GOOGLE_PLAY_SERVICE_ACCOUNT_PATH'],
      aab: ENV['AAB_FILE_NAME'],
      package_name: ENV['ANDROID_PACKAGE_NAME'],
      release_status: "draft"
    )
  end

  lane :appcenter_staging do
    ensure_env_vars(
      env_vars: ['APPCENTER_API_KEY','APK_FILE_NAME']
    )
    appcenter_upload(
      api_token: ENV["APPCENTER_API_KEY"],
      owner_name: "AtB-AS",
      app_name: "MittAtb",
      owner_type: "organization",
      destinations: "*",
      file: ENV['APK_FILE_NAME'],
      notify_testers: true
    )
  end

  lane :appcenter_alpha do
    ensure_env_vars(
      env_vars: ['APPCENTER_API_KEY', 'RELEASE_NOTES', 'RELEASE_URL']
    )
    appcenter_upload(
      api_token: ENV["APPCENTER_API_KEY"],
      owner_name: "AtB-AS",
      app_name: "MittAtb",
      owner_type: "organization",
      file: "app-store.apk",
      destination_type: "store",
      destinations: "Alpha",
      release_notes: ENV['RELEASE_NOTES'][0..499],
      release_notes_link: ENV['RELEASE_URL']
    )
  end
end




